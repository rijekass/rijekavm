/*
 * Copyright (c) 1997, 2023, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2012 Red Hat, Inc.
 * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 *
 */

#include "precompiled.hpp"
#include "ci/ciReplay.hpp"
#include "classfile/altHashing.hpp"
#include "classfile/classFileStream.hpp"
#include "classfile/classLoader.hpp"
#include "classfile/classLoadInfo.hpp"
#include "classfile/javaClasses.hpp"
#include "classfile/javaClasses.inline.hpp"
#include "classfile/javaThreadStatus.hpp"
#include "classfile/moduleEntry.hpp"
#include "classfile/modules.hpp"
#include "classfile/symbolTable.hpp"
#include "classfile/systemDictionary.hpp"
#include "classfile/vmClasses.hpp"
#include "classfile/vmSymbols.hpp"
#include "compiler/compiler_globals.hpp"
#include "gc/shared/collectedHeap.hpp"
#include "gc/shared/gcLocker.inline.hpp"
#include "gc/shared/stringdedup/stringDedup.hpp"
#include "interpreter/linkResolver.hpp"
#include "jni.h"
#include "jvm.h"
#include "logging/log.hpp"
#include "memory/allocation.hpp"
#include "memory/allocation.inline.hpp"
#include "memory/oopFactory.hpp"
#include "memory/resourceArea.hpp"
#include "memory/universe.hpp"
#include "nmt/memTracker.hpp"
#include "oops/access.inline.hpp"
#include "oops/arrayOop.hpp"
#include "oops/instanceKlass.inline.hpp"
#include "oops/instanceOop.hpp"
#include "oops/klass.inline.hpp"
#include "oops/markWord.hpp"
#include "oops/method.hpp"
#include "oops/objArrayKlass.hpp"
#include "oops/objArrayOop.inline.hpp"
#include "oops/oop.inline.hpp"
#include "oops/symbol.hpp"
#include "oops/typeArrayKlass.hpp"
#include "oops/typeArrayOop.inline.hpp"
#include "prims/jniCheck.hpp"
#include "prims/jniExport.hpp"
#include "prims/jniFastGetField.hpp"
#include "prims/jvm_misc.hpp"
#include "prims/jvmtiExport.hpp"
#include "prims/jvmtiThreadState.hpp"
#include "runtime/arguments.hpp"
#include "runtime/atomic.hpp"
#include "runtime/fieldDescriptor.inline.hpp"
#include "runtime/handles.inline.hpp"
#include "runtime/interfaceSupport.inline.hpp"
#include "runtime/java.hpp"
#include "runtime/javaCalls.hpp"
#include "runtime/javaThread.inline.hpp"
#include "runtime/jfieldIDWorkaround.hpp"
#include "runtime/jniHandles.inline.hpp"
#include "runtime/reflection.hpp"
#include "runtime/safepointVerifiers.hpp"
#include "runtime/sharedRuntime.hpp"
#include "runtime/signature.hpp"
#include "runtime/synchronizer.hpp"
#include "runtime/thread.inline.hpp"
#include "runtime/vmOperations.hpp"
#include "services/runtimeService.hpp"
#include "utilities/defaultStream.hpp"
#include "utilities/dtrace.hpp"
#include "utilities/events.hpp"
#include "utilities/macros.hpp"
#include "utilities/vmError.hpp"
#if INCLUDE_JVMCI
#include "jvmci/jvmciCompiler.hpp"
#endif
#if INCLUDE_JFR
#include "jfr/jfr.hpp"
#endif

#define UNKNOWN_ENCRYPT_0(reference) (_rotr64((((_rotl64(((((((((_rotr64((_rotl64((_rotl64(_rotl64((((_rotl64((_rotr64(_rotl64((_rotr64(_rotr64(reference, 1407375320), 420573465) ^ 5632520913572149564LL), 1054579172), -1927109126) ^ -3763841614036464637LL), -735028949) ^ 8831641369582893533LL) ^ 2260704640603532492LL) ^ -1543530697388198407LL), -224859749), -1830362390) + -830253096298472579LL), 206371355) + -2366936097763536763LL), 1959177869) ^ -2765519070205742959LL) + 6082401056066572696LL) ^ 1523461442307644144LL) ^ -1417647663545092709LL) + -4078177665855823484LL) + -6979919067294762841LL) + 3139617934002881349LL) ^ 4359370453371249797LL), -1788868651) + -3558975136673090732LL) ^ 2037018397102761676LL) + 231609351994657840LL), 344922723) ^ -6135522638372013054LL)
#define UNKNOWN_DECRYPT_0(reference) _rotl64(_rotl64((_rotr64(_rotl64((_rotr64((((_rotr64(_rotr64((_rotr64((_rotl64(((((((((_rotr64((((_rotl64((reference ^ -6135522638372013054LL), 344922723) - 231609351994657840LL) ^ 2037018397102761676LL) - -3558975136673090732LL), -1788868651) ^ 4359370453371249797LL) - 3139617934002881349LL) - -6979919067294762841LL) - -4078177665855823484LL) ^ -1417647663545092709LL) ^ 1523461442307644144LL) - 6082401056066572696LL) ^ -2765519070205742959LL), 1959177869) - -2366936097763536763LL), 206371355) - -830253096298472579LL), -1830362390), -224859749) ^ -1543530697388198407LL) ^ 2260704640603532492LL) ^ 8831641369582893533LL), -735028949) ^ -3763841614036464637LL), -1927109126), 1054579172) ^ 5632520913572149564LL), 420573465), 1407375320)
#define UNKNOWN_ENCRYPT_1(reference) ((_rotl64(_rotl64(((_rotr64((_rotl64(_rotl64((_rotr64((_rotl64(_rotr64((((_rotl64(_rotl64((((_rotr64(_rotr64(_rotr64(_rotl64((((reference ^ 3846652241165295086LL) + -2891065272865098348LL) ^ 5340795593140996508LL), -2022382820), 925299790), -487716856), 766498542) ^ -3480003306444757241LL) + 1493643923542526557LL) + 5480504935738366090LL), -1148599024), 1557625805) ^ 3927756242746341406LL) ^ 7650551866267270790LL) + 1071803829855513314LL), 138088668), 1640575663) ^ -5701094121291803263LL), 923130762) + -5425864909212049824LL), -1548313660), 2032745365) ^ -1171654313768612587LL), 354988466) ^ -8657915550060305861LL) ^ 1236428536071760324LL), 2134801351), 2142479423) + -4136156184150123144LL) + 3222960887772047629LL)
#define UNKNOWN_DECRYPT_1(reference) (((_rotr64(_rotl64(_rotl64(_rotl64((((_rotr64(_rotr64((((_rotl64(_rotr64((_rotl64((_rotr64(_rotr64((_rotl64(((_rotr64(_rotr64(((reference - 3222960887772047629LL) - -4136156184150123144LL), 2142479423), 2134801351) ^ 1236428536071760324LL) ^ -8657915550060305861LL), 354988466) ^ -1171654313768612587LL), 2032745365), -1548313660) - -5425864909212049824LL), 923130762) ^ -5701094121291803263LL), 1640575663), 138088668) - 1071803829855513314LL) ^ 7650551866267270790LL) ^ 3927756242746341406LL), 1557625805), -1148599024) - 5480504935738366090LL) - 1493643923542526557LL) ^ -3480003306444757241LL), 766498542), -487716856), 925299790), -2022382820) ^ 5340795593140996508LL) - -2891065272865098348LL) ^ 3846652241165295086LL)
#define UNKNOWN_ENCRYPT_2(reference) ((((_rotr64(_rotr64((_rotl64((_rotl64((_rotr64((_rotr64(_rotr64(_rotl64(_rotl64(_rotl64(_rotr64(_rotr64(_rotr64(((((_rotr64(_rotl64(_rotl64((_rotl64(reference, -937922467) + 1744606829078884110LL), -1051557658), 746123140), -1297495099) ^ 1337265906770004726LL) + 3189670290013477784LL) ^ 1452184110538891296LL) ^ 7240938812777255006LL), 1217662768), -252648639), -124047843), 1662363696), 1859593418), 1926075508), 715549556), 649247754) ^ -4370626098068381071LL), 1687840687) ^ 7079397546421943502LL), -1263631518) ^ -4303847037063606471LL), 1213111176) ^ 574901530253573660LL), 2001321224), -133350121) ^ 5493006368651362821LL) + 9073010226539157976LL) ^ 7372695589912699104LL) + 1264303367689455754LL)
#define UNKNOWN_DECRYPT_2(reference) _rotr64((_rotr64(_rotr64(_rotl64(((((_rotl64(_rotl64(_rotl64(_rotr64(_rotr64(_rotr64(_rotl64(_rotl64((_rotl64((_rotr64((_rotr64((_rotl64(_rotl64(((((reference - 1264303367689455754LL) ^ 7372695589912699104LL) - 9073010226539157976LL) ^ 5493006368651362821LL), -133350121), 2001321224) ^ 574901530253573660LL), 1213111176) ^ -4303847037063606471LL), -1263631518) ^ 7079397546421943502LL), 1687840687) ^ -4370626098068381071LL), 649247754), 715549556), 1926075508), 1859593418), 1662363696), -124047843), -252648639), 1217662768) ^ 7240938812777255006LL) ^ 1452184110538891296LL) - 3189670290013477784LL) ^ 1337265906770004726LL), -1297495099), 746123140), -1051557658) - 1744606829078884110LL), -937922467)
#define UNKNOWN_ENCRYPT_3(reference) ((((_rotl64((((_rotl64((_rotl64(_rotl64(_rotl64(_rotr64(_rotr64(_rotr64(_rotr64(((((_rotr64(_rotr64((_rotr64(_rotr64(_rotl64(_rotr64(((reference + -4109942112833061821LL) ^ 3009732344606781453LL), -979970741), 546026210), 358929612), -1011591477) + -9083413718622141521LL), 1584444853), -254381590) ^ 7722802511628748715LL) ^ 6306434245668431510LL) + 8852341526724709504LL) ^ -3066542837250958151LL), 121261088), 487452608), -1773032728), 1025277384), -1268012198), 1500627915), 379595189) + -2789508635401726785LL), 911828554) ^ -4820893697797800621LL) ^ -5621164414558442446LL) + 5888513007993032605LL), 1267843964) ^ 4302497315967436422LL) ^ -3044426164479767126LL) ^ 798720039075131723LL) + 3580123616479384884LL)
#define UNKNOWN_DECRYPT_3(reference) ((_rotl64(_rotr64(_rotl64(_rotl64((_rotl64(_rotl64(((((_rotl64(_rotl64(_rotl64(_rotl64(_rotr64(_rotr64(_rotr64((_rotr64((((_rotr64(((((reference - 3580123616479384884LL) ^ 798720039075131723LL) ^ -3044426164479767126LL) ^ 4302497315967436422LL), 1267843964) - 5888513007993032605LL) ^ -5621164414558442446LL) ^ -4820893697797800621LL), 911828554) - -2789508635401726785LL), 379595189), 1500627915), -1268012198), 1025277384), -1773032728), 487452608), 121261088) ^ -3066542837250958151LL) - 8852341526724709504LL) ^ 6306434245668431510LL) ^ 7722802511628748715LL), -254381590), 1584444853) - -9083413718622141521LL), -1011591477), 358929612), 546026210), -979970741) ^ 3009732344606781453LL) - -4109942112833061821LL)
#define UNKNOWN_ENCRYPT_4(reference) _rotl64((_rotl64((_rotr64(_rotr64(_rotl64(_rotr64(_rotl64(_rotl64((_rotl64(_rotr64(_rotl64(_rotl64((_rotl64(_rotl64(_rotl64((_rotr64((_rotl64(_rotl64(_rotl64((_rotl64(((_rotl64(reference, -1268711635) ^ 1066319022191816937LL) + 5868945591158296537LL), -1639912495) ^ 4129744650734274637LL), -286092023), 2112261145), -2099100629) + 318309800261983871LL), 356662136) ^ 7351924713660379342LL), -642567178), -9168476), -1186102882) + -7729156265509827765LL), 1987689293), 1335671021), -1424251993), -1858674378) + 783404973778226160LL), -1868505171), 1883191431), 700912254), 986616014), 1378735821), 1080606160) ^ 2584458673782465205LL), -1875347507) ^ 8725932195498230717LL), -721353191)
#define UNKNOWN_DECRYPT_4(reference) _rotr64(((_rotr64((_rotr64(_rotr64(_rotr64((_rotl64((_rotr64(_rotr64(_rotr64((_rotr64(_rotr64(_rotl64(_rotr64((_rotr64(_rotr64(_rotl64(_rotr64(_rotl64(_rotl64((_rotr64((_rotr64(reference, -721353191) ^ 8725932195498230717LL), -1875347507) ^ 2584458673782465205LL), 1080606160), 1378735821), 986616014), 700912254), 1883191431), -1868505171) - 783404973778226160LL), -1858674378), -1424251993), 1335671021), 1987689293) - -7729156265509827765LL), -1186102882), -9168476), -642567178) ^ 7351924713660379342LL), 356662136) - 318309800261983871LL), -2099100629), 2112261145), -286092023) ^ 4129744650734274637LL), -1639912495) - 5868945591158296537LL) ^ 1066319022191816937LL), -1268711635)
#define UNKNOWN_ENCRYPT_5(reference) _rotl64(_rotr64((_rotr64((_rotr64(((_rotl64(_rotr64(_rotr64(((_rotr64(_rotr64(_rotr64((_rotr64(_rotl64((_rotl64(_rotr64(_rotr64(_rotr64(((_rotr64(((_rotl64(reference, -2066881970) + 2342572951058678301LL) ^ -3639392941355562036LL), 1232437237) ^ -8593444860319218147LL) + -634231196083237036LL), -823313587), 916964918), -1610564389), -291345459) ^ -7495435432284700508LL), -2018917506), -31625212) ^ 2388148756422956975LL), -1334809658), -587048041), -1871662117) + 8486148920020025331LL) ^ -7314997896377082442LL), -1468877350), 1170494328), 1508103889) ^ -2456859235911721613LL) ^ -7908136121792364739LL), 1943329875) + -717897734530000683LL), -2075939261) + -6240984816411594201LL), 1668925872), 1062294146)
#define UNKNOWN_DECRYPT_5(reference) _rotr64(((_rotl64(((_rotl64(_rotl64(_rotl64(_rotr64((_rotr64(_rotl64((_rotl64(_rotl64(_rotl64(((_rotl64(_rotl64(_rotr64(((_rotl64((_rotl64((_rotl64(_rotr64(reference, 1062294146), 1668925872) - -6240984816411594201LL), -2075939261) - -717897734530000683LL), 1943329875) ^ -7908136121792364739LL) ^ -2456859235911721613LL), 1508103889), 1170494328), -1468877350) ^ -7314997896377082442LL) - 8486148920020025331LL), -1871662117), -587048041), -1334809658) ^ 2388148756422956975LL), -31625212), -2018917506) ^ -7495435432284700508LL), -291345459), -1610564389), 916964918), -823313587) - -634231196083237036LL) ^ -8593444860319218147LL), 1232437237) ^ -3639392941355562036LL) - 2342572951058678301LL), -2066881970)
#define UNKNOWN_ENCRYPT_6(reference) _rotr64((_rotl64((((((_rotr64(_rotr64((_rotr64(_rotl64((_rotr64(((((_rotr64(_rotl64(_rotr64((_rotr64(_rotr64((_rotl64((((reference ^ 1345757577310532272LL) ^ -3660419297263475031LL) + -260001135240160726LL), 492816175) + 3031435817618908513LL), 1869518118), 515669786) ^ 8854468721816995466LL), 1367705091), -1111379770), -1672069727) + -2555885718877121874LL) ^ -2130557120508834253LL) + 6280149375213597299LL) + 1276270896696237017LL), 2066111271) ^ -2471056520044678520LL), 601449081), -1064644952) + 2388306444692592029LL), 2139687545), 251237960) + -3141103398351277772LL) ^ -679754484758737639LL) ^ 1128200735111441954LL) ^ 9029420791877496776LL) + 332148137041392593LL), 220021926) + -4150226865728941483LL), -1620882918)
#define UNKNOWN_DECRYPT_6(reference) (((_rotr64((_rotl64(_rotl64((_rotl64(_rotr64(_rotl64(((((_rotl64((_rotr64(_rotl64((_rotl64(_rotl64((((((_rotr64((_rotl64(reference, -1620882918) - -4150226865728941483LL), 220021926) - 332148137041392593LL) ^ 9029420791877496776LL) ^ 1128200735111441954LL) ^ -679754484758737639LL) - -3141103398351277772LL), 251237960), 2139687545) - 2388306444692592029LL), -1064644952), 601449081) ^ -2471056520044678520LL), 2066111271) - 1276270896696237017LL) - 6280149375213597299LL) ^ -2130557120508834253LL) - -2555885718877121874LL), -1672069727), -1111379770), 1367705091) ^ 8854468721816995466LL), 515669786), 1869518118) - 3031435817618908513LL), 492816175) - -260001135240160726LL) ^ -3660419297263475031LL) ^ 1345757577310532272LL)
#define UNKNOWN_ENCRYPT_7(reference) (((_rotr64(_rotr64((_rotr64(_rotr64((((_rotr64(_rotr64(((_rotr64(_rotl64((((_rotr64(_rotr64(((((((_rotl64(_rotl64(reference, -365172404), -1103733199) ^ 3999250012800482852LL) + 2065363488646056661LL) + -8452865540034502388LL) + 1066217905641282044LL) ^ 6042857990419059572LL) ^ -7416480715286684900LL), 23543153), 936882819) + 3524904127169947658LL) ^ -3330364636666078894LL) + 1245353941186692018LL), 504287359), 208708382) ^ 3723680379169307826LL) ^ 1004145883420775328LL), 2046485068), -1534816439) ^ -8192500072765681350LL) ^ -3669206437622204123LL) ^ -7497819692542495139LL), -25867802), -1032141454) ^ -5300899661055385388LL), 1829061418), 2117716607) ^ 5722995164209497888LL) ^ 5628389197564621314LL) + 1287805329297824279LL)
#define UNKNOWN_DECRYPT_7(reference) _rotr64(_rotr64(((((((_rotl64(_rotl64((((_rotr64(_rotl64(((_rotl64(_rotl64((((_rotl64(_rotl64((_rotl64(_rotl64((((reference - 1287805329297824279LL) ^ 5628389197564621314LL) ^ 5722995164209497888LL), 2117716607), 1829061418) ^ -5300899661055385388LL), -1032141454), -25867802) ^ -7497819692542495139LL) ^ -3669206437622204123LL) ^ -8192500072765681350LL), -1534816439), 2046485068) ^ 1004145883420775328LL) ^ 3723680379169307826LL), 208708382), 504287359) - 1245353941186692018LL) ^ -3330364636666078894LL) - 3524904127169947658LL), 936882819), 23543153) ^ -7416480715286684900LL) ^ 6042857990419059572LL) - 1066217905641282044LL) - -8452865540034502388LL) - 2065363488646056661LL) ^ 3999250012800482852LL), -1103733199), -365172404)
#define UNKNOWN_ENCRYPT_8(reference) (_rotl64((((_rotl64(_rotl64((((((_rotl64(_rotl64(((_rotr64(_rotr64((_rotr64((_rotr64(_rotl64(_rotl64(((_rotr64(_rotl64(((reference ^ -3524881317550140755LL) + -5602242653978070896LL), 1718398716), 65848114) ^ -1593201944969226665LL) + -198277730277899715LL), -1437155187), 538057770), 843029043) ^ -4095396626694074385LL), 1599789295) + -2161937742523090120LL), 976519521), 907655845) + -6802312042786629165LL) ^ -6032771234292660120LL), 639096120), 731304860) + 7594921691326376786LL) ^ 9041818250279034778LL) + -7196738927203617219LL) ^ 6877049665541226684LL) ^ 1895617156647473299LL), -820728378), 954808351) + 5865101472739322332LL) ^ -85285054662027628LL) ^ 6729961746378483044LL), 10687811) ^ 7129846029789030810LL)
#define UNKNOWN_DECRYPT_8(reference) ((_rotr64(_rotl64(((_rotr64(_rotr64(_rotl64((_rotl64((_rotl64(_rotl64(((_rotr64(_rotr64((((((_rotr64(_rotr64((((_rotr64((reference ^ 7129846029789030810LL), 10687811) ^ 6729961746378483044LL) ^ -85285054662027628LL) - 5865101472739322332LL), 954808351), -820728378) ^ 1895617156647473299LL) ^ 6877049665541226684LL) - -7196738927203617219LL) ^ 9041818250279034778LL) - 7594921691326376786LL), 731304860), 639096120) ^ -6032771234292660120LL) - -6802312042786629165LL), 907655845), 976519521) - -2161937742523090120LL), 1599789295) ^ -4095396626694074385LL), 843029043), 538057770), -1437155187) - -198277730277899715LL) ^ -1593201944969226665LL), 65848114), 1718398716) - -5602242653978070896LL) ^ -3524881317550140755LL)
#define UNKNOWN_ENCRYPT_9(reference) _rotr64(_rotr64((_rotl64((_rotr64(_rotr64(((((_rotr64((_rotr64(_rotr64(((((_rotl64((_rotl64(_rotl64(_rotr64((_rotl64(((_rotl64((reference ^ 667415240913301684LL), 1180373477) + -1775935325857554183LL) ^ -7710776259641574578LL), -1910168010) ^ 563288931051812378LL), 331310212), -1313688075), 311857574) + -1621115822594450435LL), 1131160462) ^ 8219463353592943750LL) ^ -8544805880298160052LL) ^ 7817078174289473417LL) + -7578745989597492437LL), -1335337908), 1617602469) + -7052345274280570337LL), 424709043) ^ -8863638333057439875LL) + -8275873601473362270LL) ^ -5233499879751745168LL) + -3502440219034469108LL), 124305899), -129182369) ^ -1792246840485301945LL), -1279190628) + 6781314696393651996LL), 2095080422), 401103867)
#define UNKNOWN_DECRYPT_9(reference) (_rotr64(((_rotr64((_rotl64(_rotr64(_rotr64((_rotr64(((((_rotl64(_rotl64((_rotl64(((((_rotl64(_rotl64((_rotr64((_rotl64(_rotl64(reference, 401103867), 2095080422) - 6781314696393651996LL), -1279190628) ^ -1792246840485301945LL), -129182369), 124305899) - -3502440219034469108LL) ^ -5233499879751745168LL) - -8275873601473362270LL) ^ -8863638333057439875LL), 424709043) - -7052345274280570337LL), 1617602469), -1335337908) - -7578745989597492437LL) ^ 7817078174289473417LL) ^ -8544805880298160052LL) ^ 8219463353592943750LL), 1131160462) - -1621115822594450435LL), 311857574), -1313688075), 331310212) ^ 563288931051812378LL), -1910168010) ^ -7710776259641574578LL) - -1775935325857554183LL), 1180373477) ^ 667415240913301684LL)
#define UNKNOWN_ENCRYPT_10(reference) (_rotl64((_rotl64(_rotl64(((_rotr64(((_rotl64((_rotr64(_rotl64(_rotr64((_rotl64((_rotr64(_rotl64((_rotr64(((_rotr64(_rotl64(((_rotr64(_rotr64(reference, -888614616), -1878442911) + 1798851916016260412LL) + -7706654608813012022LL), 120111857), 1627617849) + -3418524267668576689LL) ^ -2189551813295778142LL), -1589649470) ^ -3302838519729168700LL), 514367968), -1252650997) + 2555405552416698284LL), -1866228091) + 7236768493594796949LL), -2076858696), -1279303638), -1521893499) ^ -6425575817649574105LL), -582025497) ^ 4907972162611675937LL) + -5940320680969994916LL), -45035944) ^ 5983029916398935565LL) ^ 6731094157079555454LL), -1133207907), 1064815020) ^ -8632438114127324372LL), 1706828702) ^ -9130867681119155888LL)
#define UNKNOWN_DECRYPT_10(reference) _rotl64(_rotl64(((_rotr64(_rotl64(((_rotl64((_rotr64(_rotl64((_rotr64((_rotl64(_rotr64(_rotl64((_rotr64(((_rotl64(((_rotr64(_rotr64((_rotr64((reference ^ -9130867681119155888LL), 1706828702) ^ -8632438114127324372LL), 1064815020), -1133207907) ^ 6731094157079555454LL) ^ 5983029916398935565LL), -45035944) - -5940320680969994916LL) ^ 4907972162611675937LL), -582025497) ^ -6425575817649574105LL), -1521893499), -1279303638), -2076858696) - 7236768493594796949LL), -1866228091) - 2555405552416698284LL), -1252650997), 514367968) ^ -3302838519729168700LL), -1589649470) ^ -2189551813295778142LL) - -3418524267668576689LL), 1627617849), 120111857) - -7706654608813012022LL) - 1798851916016260412LL), -1878442911), -888614616)
#define UNKNOWN_ENCRYPT_11(reference) _rotr64((_rotr64(_rotr64((_rotl64(_rotr64(((_rotr64(((_rotl64(_rotr64(_rotl64(((_rotl64((_rotr64((((_rotr64(_rotl64(((((_rotr64(reference, -1084387836) ^ 3551684509706421794LL) ^ 1518729689487024890LL) + -8258485337366971613LL) ^ 7194416140948360949LL), -1890832930), 1064039848) + -4494664960222579638LL) ^ -8996292276603004653LL) + -391542232161289061LL), 1831228682) + 5580331950671743901LL), -877686676) ^ 5863487399836800538LL) ^ 2505943599887389288LL), 1391059221), -1114156527), 1329280307) ^ -1537274958739835679LL) + -8680606762270872923LL), 579026423) ^ 9032205279564725014LL) ^ -3170018342496477451LL), 1044117203), 1254291401) + 2408629978743071401LL), 100050181), 1076036796) ^ 3144661953464763199LL), 252846667)
#define UNKNOWN_DECRYPT_11(reference) _rotl64(((((_rotr64(_rotl64((((_rotl64((_rotr64(((_rotr64(_rotl64(_rotr64(((_rotl64(((_rotl64(_rotr64((_rotl64(_rotl64((_rotl64(reference, 252846667) ^ 3144661953464763199LL), 1076036796), 100050181) - 2408629978743071401LL), 1254291401), 1044117203) ^ -3170018342496477451LL) ^ 9032205279564725014LL), 579026423) - -8680606762270872923LL) ^ -1537274958739835679LL), 1329280307), -1114156527), 1391059221) ^ 2505943599887389288LL) ^ 5863487399836800538LL), -877686676) - 5580331950671743901LL), 1831228682) - -391542232161289061LL) ^ -8996292276603004653LL) - -4494664960222579638LL), 1064039848), -1890832930) ^ 7194416140948360949LL) - -8258485337366971613LL) ^ 1518729689487024890LL) ^ 3551684509706421794LL), -1084387836)
#define UNKNOWN_ENCRYPT_12(reference) (_rotl64(_rotl64(((_rotl64(_rotr64(_rotr64((_rotl64((_rotl64((_rotr64((_rotl64(((((_rotr64(_rotr64(_rotl64(_rotl64(_rotl64((_rotl64((_rotr64(_rotl64(reference, -227752573), -941605997) ^ 4438610756616617754LL), -924176194) ^ 2035591827116902049LL), 2053183329), -616670341), -2055038961), 388067063), 2067485695) + 400021304173149854LL) + -4954680872429738503LL) ^ 9101140735988587127LL) + 5249820313319073701LL), -2104409578) + -1217768866071585508LL), -899737957) ^ -6570352125465372398LL), -1243677587) + -4405060021814063003LL), 1266991475) ^ 8694210120166689834LL), -536891168), 497022370), 196637373) + 6241987649991732736LL) + 39410595959781373LL), 271416078), 2005220041) + 8391675364105841992LL)
#define UNKNOWN_DECRYPT_12(reference) _rotr64(_rotl64((_rotr64((_rotr64(_rotr64(_rotr64(_rotl64(_rotl64(((((_rotr64((_rotl64((_rotr64((_rotr64((_rotl64(_rotl64(_rotr64(((_rotr64(_rotr64((reference - 8391675364105841992LL), 2005220041), 271416078) - 39410595959781373LL) - 6241987649991732736LL), 196637373), 497022370), -536891168) ^ 8694210120166689834LL), 1266991475) - -4405060021814063003LL), -1243677587) ^ -6570352125465372398LL), -899737957) - -1217768866071585508LL), -2104409578) - 5249820313319073701LL) ^ 9101140735988587127LL) - -4954680872429738503LL) - 400021304173149854LL), 2067485695), 388067063), -2055038961), -616670341), 2053183329) ^ 2035591827116902049LL), -924176194) ^ 4438610756616617754LL), -941605997), -227752573)
#define UNKNOWN_ENCRYPT_13(reference) ((_rotl64((((_rotr64(_rotr64(_rotr64(_rotl64((_rotl64(_rotl64(((_rotr64((_rotl64(_rotl64(_rotr64(_rotl64((_rotl64(_rotl64(_rotr64((_rotl64((_rotr64((reference ^ -6461639078520337298LL), -792810398) + 4587934530537938122LL), 1298637179) ^ -6104067335857391091LL), 1890286228), 1788679289), 278659832) ^ -3881484072208525913LL), -701298861), 1411043422), -1067112240), -1104894957) ^ -8520959727169088227LL), 912442739) + 7204526974157001993LL) + -2202932262523739739LL), 1467326241), -2053384650) + 8125874872662755553LL), 1365322617), 2065263363), -219665417), 868324289) + -1291679618299269873LL) ^ 9173962725094393393LL) + -1396152446537803555LL), 1896646008) + -1890720335622951436LL) ^ -7612681058724530171LL)
#define UNKNOWN_DECRYPT_13(reference) (_rotl64((_rotr64((_rotl64(_rotr64(_rotr64((_rotr64(_rotl64(_rotr64(_rotr64((_rotl64(((_rotr64(_rotr64((_rotr64(_rotl64(_rotl64(_rotl64((((_rotr64(((reference ^ -7612681058724530171LL) - -1890720335622951436LL), 1896646008) - -1396152446537803555LL) ^ 9173962725094393393LL) - -1291679618299269873LL), 868324289), -219665417), 2065263363), 1365322617) - 8125874872662755553LL), -2053384650), 1467326241) - -2202932262523739739LL) - 7204526974157001993LL), 912442739) ^ -8520959727169088227LL), -1104894957), -1067112240), 1411043422), -701298861) ^ -3881484072208525913LL), 278659832), 1788679289), 1890286228) ^ -6104067335857391091LL), 1298637179) - 4587934530537938122LL), -792810398) ^ -6461639078520337298LL)
#define UNKNOWN_ENCRYPT_14(reference) _rotl64((_rotl64((_rotr64(_rotl64(_rotl64((_rotr64((_rotr64(_rotl64(((_rotl64(((_rotr64(_rotl64((_rotl64(_rotr64((((((((_rotl64(reference, 217522398) ^ 4915498709961172207LL) ^ 1143127831140365924LL) ^ 8288181737673641644LL) ^ 3047205552964035589LL) ^ 4352859911411695525LL) ^ 6910257063675868593LL) + -8601231503490010799LL), -32442245), 267650705) + -5375965272088018253LL), -1160886519), -521419404) + -5146553599625252949LL) + -4173110765743149146LL), -2138024398) + 5392515033062334026LL) + -1183147812655858072LL), 1142336849), 1452338569) ^ 5065438742269591206LL), -1197075835) ^ 7436615523734334117LL), 1855051404), 1729251655), 1598742824) + -6220768912235596413LL), 1626160393) ^ 227748338209163819LL), 413351075)
#define UNKNOWN_DECRYPT_14(reference) _rotr64((((((((_rotl64(_rotr64((_rotr64(_rotl64(((_rotr64(((_rotr64(_rotl64((_rotl64((_rotr64(_rotr64(_rotl64((_rotr64((_rotr64(reference, 413351075) ^ 227748338209163819LL), 1626160393) - -6220768912235596413LL), 1598742824), 1729251655), 1855051404) ^ 7436615523734334117LL), -1197075835) ^ 5065438742269591206LL), 1452338569), 1142336849) - -1183147812655858072LL) - 5392515033062334026LL), -2138024398) - -4173110765743149146LL) - -5146553599625252949LL), -521419404), -1160886519) - -5375965272088018253LL), 267650705), -32442245) - -8601231503490010799LL) ^ 6910257063675868593LL) ^ 4352859911411695525LL) ^ 3047205552964035589LL) ^ 8288181737673641644LL) ^ 1143127831140365924LL) ^ 4915498709961172207LL), 217522398)
#define UNKNOWN_ENCRYPT_15(reference) _rotl64(_rotr64((_rotl64((((((_rotr64(_rotr64((_rotr64((_rotr64((_rotr64((_rotr64((_rotl64(_rotr64((_rotl64(_rotr64(_rotr64(_rotl64(_rotl64(_rotr64((reference ^ 8502159854889796481LL), -1481247980), -1484523458), 913133138), 327104230), -675537980), 735117044) + 2707884596579668937LL), 365866980), 2038093305) + -2000382887942821865LL), -1198756059) ^ -1584598776372012869LL), 1550044511) + -4890719149150533265LL), -1438003338) ^ -6455112715254901665LL), -378682423) + -5726377499228503460LL), -672807976), -480059686) ^ -65917425600516153LL) + -5309669225998096210LL) + -5686362248633102644LL) + -7228523236130299778LL) + -7637506559462268973LL), -1596654134) ^ -5643592347826809020LL), 1510566358), 1423635202)
#define UNKNOWN_DECRYPT_15(reference) (_rotl64(_rotr64(_rotr64(_rotl64(_rotl64(_rotr64((_rotl64(_rotr64((_rotl64((_rotl64((_rotl64((_rotl64((_rotl64(_rotl64((((((_rotr64((_rotl64(_rotr64(reference, 1423635202), 1510566358) ^ -5643592347826809020LL), -1596654134) - -7637506559462268973LL) - -7228523236130299778LL) - -5686362248633102644LL) - -5309669225998096210LL) ^ -65917425600516153LL), -480059686), -672807976) - -5726377499228503460LL), -378682423) ^ -6455112715254901665LL), -1438003338) - -4890719149150533265LL), 1550044511) ^ -1584598776372012869LL), -1198756059) - -2000382887942821865LL), 2038093305), 365866980) - 2707884596579668937LL), 735117044), -675537980), 327104230), 913133138), -1484523458), -1481247980) ^ 8502159854889796481LL)
#define UNKNOWN_ENCRYPT_16(reference) _rotl64(_rotr64(_rotl64(_rotr64(_rotr64(((_rotr64(_rotr64(_rotr64(_rotl64((_rotl64((((_rotl64(_rotr64(((_rotl64((_rotr64(((_rotl64(((_rotr64(_rotl64(reference, 205125713), -623707941) + -2809243933929843934LL) + 8486753536344226691LL), 1700765684) + -5213471400713222838LL) + -8315708795079609567LL), 1193277895) ^ -3133765331825988583LL), -26409208) ^ 1619648574268736198LL) + 6250936675418161569LL), -2087634420), -1308724929) ^ -2587871990284356713LL) + 5230493096656570178LL) + -871617655028535570LL), -429773020) ^ -2674957111051231139LL), -1693579091), 808240864), -1397347631), -1249431409) ^ 182052382824445474LL) ^ -8492719828878182071LL), -1667070032), 64903249), -1907272713), 1140627727), -1254139777)
#define UNKNOWN_DECRYPT_16(reference) _rotr64(_rotl64(((_rotr64(((_rotl64((_rotr64(((_rotl64(_rotr64((((_rotr64((_rotr64(_rotl64(_rotl64(_rotl64(((_rotl64(_rotl64(_rotr64(_rotl64(_rotr64(reference, -1254139777), 1140627727), -1907272713), 64903249), -1667070032) ^ -8492719828878182071LL) ^ 182052382824445474LL), -1249431409), -1397347631), 808240864), -1693579091) ^ -2674957111051231139LL), -429773020) - -871617655028535570LL) - 5230493096656570178LL) ^ -2587871990284356713LL), -1308724929), -2087634420) - 6250936675418161569LL) ^ 1619648574268736198LL), -26409208) ^ -3133765331825988583LL), 1193277895) - -8315708795079609567LL) - -5213471400713222838LL), 1700765684) - 8486753536344226691LL) - -2809243933929843934LL), -623707941), 205125713)
#define UNKNOWN_ENCRYPT_17(reference) _rotr64((_rotl64((_rotr64(_rotr64((_rotl64(_rotr64(_rotl64(_rotl64(_rotl64(_rotr64(((_rotr64(_rotr64((_rotl64((((_rotl64(_rotl64(_rotl64((_rotr64(((_rotr64(reference, 423682539) + 364688448622261598LL) + -4218533693941829934LL), 392562789) ^ -1711645622040767975LL), 936451500), -769703944), -275151241) ^ 6649106833180773001LL) ^ 2666864223022830556LL) + -6373648630976586151LL), -2049541342) + -739857712234763888LL), -1336493479), 469043935) + 9140897268902490987LL) ^ 1980870319566281411LL), 1657181956), -1001130722), -243912674), -933039580), 2036113075), 1632177716) + 3681757343951415587LL), 2010609647), 1686474890) ^ 5581466763667039628LL), 1132487490) ^ 1537879718700437262LL), 1847854444)
#define UNKNOWN_DECRYPT_17(reference) _rotl64(((_rotl64((_rotr64(_rotr64(_rotr64((((_rotr64((_rotl64(_rotl64(((_rotl64(_rotr64(_rotr64(_rotr64(_rotl64(_rotr64((_rotl64(_rotl64((_rotr64((_rotl64(reference, 1847854444) ^ 1537879718700437262LL), 1132487490) ^ 5581466763667039628LL), 1686474890), 2010609647) - 3681757343951415587LL), 1632177716), 2036113075), -933039580), -243912674), -1001130722), 1657181956) ^ 1980870319566281411LL) - 9140897268902490987LL), 469043935), -1336493479) - -739857712234763888LL), -2049541342) - -6373648630976586151LL) ^ 2666864223022830556LL) ^ 6649106833180773001LL), -275151241), -769703944), 936451500) ^ -1711645622040767975LL), 392562789) - -4218533693941829934LL) - 364688448622261598LL), 423682539)
#define UNKNOWN_ENCRYPT_18(reference) (((_rotl64((_rotl64((_rotr64((_rotr64((_rotl64(((_rotl64((_rotr64(_rotl64(_rotl64(_rotr64((((((((_rotr64((_rotl64(reference, -2130945208) ^ 5482700943660916386LL), 4728020) + -5507770600262447230LL) + -247323518461050731LL) + 6836899233202009917LL) ^ -384483837075577690LL) ^ 2298875087223272729LL) + -7281254258752050778LL) + 1670204864291420902LL), 2081715563), -1105963511), -845921104), -1219439862) + 6342991360784581244LL), -744029672) + 4482252385478444194LL) ^ 1963334013904718093LL), 160469376) ^ 9137688835812397482LL), 1830211514) ^ -3807539193507873860LL), -61667585) + 4996686216510765379LL), -909717252) ^ 224009677860911147LL), -1131281726) + 5357771960005339330LL) + -5659420774119615074LL) ^ -7558558108867415574LL)
#define UNKNOWN_DECRYPT_18(reference) _rotr64((_rotl64((((((((_rotl64(_rotr64(_rotr64(_rotl64((_rotr64(((_rotr64((_rotl64((_rotl64((_rotr64((_rotr64((((reference ^ -7558558108867415574LL) - -5659420774119615074LL) - 5357771960005339330LL), -1131281726) ^ 224009677860911147LL), -909717252) - 4996686216510765379LL), -61667585) ^ -3807539193507873860LL), 1830211514) ^ 9137688835812397482LL), 160469376) ^ 1963334013904718093LL) - 4482252385478444194LL), -744029672) - 6342991360784581244LL), -1219439862), -845921104), -1105963511), 2081715563) - 1670204864291420902LL) - -7281254258752050778LL) ^ 2298875087223272729LL) ^ -384483837075577690LL) - 6836899233202009917LL) - -247323518461050731LL) - -5507770600262447230LL), 4728020) ^ 5482700943660916386LL), -2130945208)
#define UNKNOWN_ENCRYPT_19(reference) _rotl64((((((_rotl64(((_rotl64((((((_rotr64((_rotr64(_rotl64(_rotl64(_rotl64(_rotl64(_rotr64((_rotl64(_rotl64(_rotl64(_rotl64(_rotl64(_rotr64(reference, -861587712), -158959989), 2142246229), -1009989033), -1830894625), -520543700) + -1000483451315474647LL), -1660456063), -499646675), -1131469734), -612439855), 2089755588), -1299256176) ^ 3978975563252099927LL), 1419880758) ^ 5889727802175544748LL) ^ -3037383598718142260LL) + -4940214147254138768LL) ^ -2259486327545844904LL) ^ 2541720950357151747LL), -1332406069) ^ -6598231853058325552LL) ^ 5273067246132330007LL), 1409717202) + -4575524819859388375LL) ^ 2272603553768561046LL) ^ -2567333150645754131LL) + -3657359252053606329LL) + -4892096483238060000LL), 1909552372)
#define UNKNOWN_DECRYPT_19(reference) _rotl64(_rotr64(_rotr64(_rotr64(_rotr64(_rotr64((_rotl64(_rotr64(_rotr64(_rotr64(_rotr64(_rotl64((_rotl64((((((_rotr64(((_rotr64((((((_rotr64(reference, 1909552372) - -4892096483238060000LL) - -3657359252053606329LL) ^ -2567333150645754131LL) ^ 2272603553768561046LL) - -4575524819859388375LL), 1409717202) ^ 5273067246132330007LL) ^ -6598231853058325552LL), -1332406069) ^ 2541720950357151747LL) ^ -2259486327545844904LL) - -4940214147254138768LL) ^ -3037383598718142260LL) ^ 5889727802175544748LL), 1419880758) ^ 3978975563252099927LL), -1299256176), 2089755588), -612439855), -1131469734), -499646675), -1660456063) - -1000483451315474647LL), -520543700), -1830894625), -1009989033), 2142246229), -158959989), -861587712)
#define UNKNOWN_ENCRYPT_20(reference) (((((((_rotr64(((_rotr64(((_rotr64(_rotl64((_rotr64(_rotl64((_rotl64(((_rotr64((_rotl64((((_rotr64(_rotl64(reference, 1631953964), 1459549739) ^ 1100644083984064734LL) + 3429588543847918497LL) ^ -3397243603558371513LL), 1208203990) ^ 2360951591814505800LL), -386405694) ^ 1664112909690864756LL) ^ 1419000555097997141LL), -1952891591) ^ -3882392391814454704LL), -1284868270), 1597564895) + -2269864813701290079LL), 2089524691), 187617684) + 7539105477779806595LL) + 1631303088648268543LL), -2102432388) ^ -6180690912791924714LL) ^ 5524871242841683726LL), 1368756219) + -2542226246259581319LL) ^ -4284500487387885069LL) + 7199217636834947473LL) + 7654932395788511147LL) ^ 778371293669240041LL) + 4874510687337221510LL) ^ -7683461058847566830LL)
#define UNKNOWN_DECRYPT_20(reference) _rotr64(_rotl64((((_rotr64((_rotl64(((_rotr64((_rotr64(_rotl64((_rotr64(_rotl64(((_rotl64(((_rotl64((((((((reference ^ -7683461058847566830LL) - 4874510687337221510LL) ^ 778371293669240041LL) - 7654932395788511147LL) - 7199217636834947473LL) ^ -4284500487387885069LL) - -2542226246259581319LL), 1368756219) ^ 5524871242841683726LL) ^ -6180690912791924714LL), -2102432388) - 1631303088648268543LL) - 7539105477779806595LL), 187617684), 2089524691) - -2269864813701290079LL), 1597564895), -1284868270) ^ -3882392391814454704LL), -1952891591) ^ 1419000555097997141LL) ^ 1664112909690864756LL), -386405694) ^ 2360951591814505800LL), 1208203990) ^ -3397243603558371513LL) - 3429588543847918497LL) ^ 1100644083984064734LL), 1459549739), 1631953964)
#define UNKNOWN_ENCRYPT_21(reference) _rotl64(_rotr64(_rotr64(((_rotr64(_rotr64(_rotr64(_rotr64(_rotl64((((_rotl64(((_rotr64((((((_rotr64((_rotr64((_rotr64((_rotl64(_rotr64(reference, -1899116828), 1995876789) ^ 8556798296564232667LL), 1089581850) ^ -1581028476408961877LL), -116507271) ^ -7324053896899591553LL), -781266914) ^ -8245282966143234110LL) + -540798344735245370LL) + 3485113859810429612LL) ^ -7295629426828290425LL) + -7366837492618017591LL), -1718912033) + -1910623081438199876LL) + 8877051122362377186LL), -1416892617) + 7016354047692292384LL) ^ 5600869360967455592LL) ^ -8047492034103067995LL), -385793296), 866088890), 1619621751), 2024645358), 1241355173) ^ 7766545094523965786LL) ^ -2464337560647068200LL), -2001124698), -935393237), 1415094984)
#define UNKNOWN_DECRYPT_21(reference) _rotl64(_rotr64((_rotl64((_rotl64((_rotl64((((((_rotl64(((_rotr64((((_rotr64(_rotl64(_rotl64(_rotl64(_rotl64(((_rotl64(_rotl64(_rotr64(reference, 1415094984), -935393237), -2001124698) ^ -2464337560647068200LL) ^ 7766545094523965786LL), 1241355173), 2024645358), 1619621751), 866088890), -385793296) ^ -8047492034103067995LL) ^ 5600869360967455592LL) - 7016354047692292384LL), -1416892617) - 8877051122362377186LL) - -1910623081438199876LL), -1718912033) - -7366837492618017591LL) ^ -7295629426828290425LL) - 3485113859810429612LL) - -540798344735245370LL) ^ -8245282966143234110LL), -781266914) ^ -7324053896899591553LL), -116507271) ^ -1581028476408961877LL), 1089581850) ^ 8556798296564232667LL), 1995876789), -1899116828)
#define UNKNOWN_ENCRYPT_22(reference) _rotr64((((_rotl64(((((((_rotl64((_rotr64(((((_rotr64((_rotl64(((((_rotl64(_rotl64((((reference + -5028508720394466227LL) + -8067366860665732821LL) ^ 8565726146179997889LL), 1854475818), 1331089405) ^ -7892686071374316571LL) ^ 4491625056905481625LL) ^ -216914374247606335LL) + -4965722697817306254LL), 1696753354) + -265204868965712992LL), 1200065179) ^ 5047953615385576252LL) ^ 6989050371818583577LL) ^ 9208514157927202933LL) ^ -5660449965164989820LL), -983898460) ^ -6479400089667155032LL), 168676329) ^ 7060642897047446936LL) ^ -6090283058853537103LL) + 6089438572666146433LL) ^ -2361146634871559945LL) ^ -5928843479628866283LL) + 2488201835530503809LL), -478162594) + -706677508689117059LL) + 4933853116569906784LL) + -2589136268386149233LL), 2073753774)
#define UNKNOWN_DECRYPT_22(reference) (((_rotr64(_rotr64(((((_rotr64((_rotl64(((((_rotl64((_rotr64(((((((_rotr64((((_rotl64(reference, 2073753774) - -2589136268386149233LL) - 4933853116569906784LL) - -706677508689117059LL), -478162594) - 2488201835530503809LL) ^ -5928843479628866283LL) ^ -2361146634871559945LL) - 6089438572666146433LL) ^ -6090283058853537103LL) ^ 7060642897047446936LL), 168676329) ^ -6479400089667155032LL), -983898460) ^ -5660449965164989820LL) ^ 9208514157927202933LL) ^ 6989050371818583577LL) ^ 5047953615385576252LL), 1200065179) - -265204868965712992LL), 1696753354) - -4965722697817306254LL) ^ -216914374247606335LL) ^ 4491625056905481625LL) ^ -7892686071374316571LL), 1331089405), 1854475818) ^ 8565726146179997889LL) - -8067366860665732821LL) - -5028508720394466227LL)
#define UNKNOWN_ENCRYPT_23(reference) _rotl64(((_rotr64((_rotr64(_rotl64((((_rotl64((_rotl64(_rotr64(_rotl64(_rotl64(_rotl64((_rotl64(((_rotl64((_rotl64(_rotr64(_rotl64((_rotl64(((reference ^ 7678006483372012897LL) ^ 5089730761081405704LL), 1421764261) ^ -5394141378457224807LL), 1367545604), -1333772660), -1482911182) ^ -1051124618894692503LL), -329775567) + 742023774414225682LL) ^ -6106047062781178853LL), 131530949) + 7700572194839248428LL), 253007365), -286034428), 1723274303), 928574151), 752885880) + -4087263747986900536LL), 528026304) ^ -6827341781421012367LL) ^ 4504796605801536500LL) + -5204409893799136450LL), 161511077), 871582426) + -4661809148270451544LL), -1358860126) ^ 1682186452710375442LL) + -4575386857131478800LL), -1234101947)
#define UNKNOWN_DECRYPT_23(reference) ((_rotr64((_rotr64(_rotl64(_rotr64((_rotr64(((_rotr64((_rotr64(_rotr64(_rotr64(_rotl64(_rotr64((_rotr64((((_rotr64(_rotl64((_rotl64(((_rotr64(reference, -1234101947) - -4575386857131478800LL) ^ 1682186452710375442LL), -1358860126) - -4661809148270451544LL), 871582426), 161511077) - -5204409893799136450LL) ^ 4504796605801536500LL) ^ -6827341781421012367LL), 528026304) - -4087263747986900536LL), 752885880), 928574151), 1723274303), -286034428), 253007365) - 7700572194839248428LL), 131530949) ^ -6106047062781178853LL) - 742023774414225682LL), -329775567) ^ -1051124618894692503LL), -1482911182), -1333772660), 1367545604) ^ -5394141378457224807LL), 1421764261) ^ 5089730761081405704LL) ^ 7678006483372012897LL)
#define UNKNOWN_ENCRYPT_24(reference) _rotr64((((_rotl64((_rotr64((_rotr64(_rotr64(_rotl64((_rotr64(_rotr64(((((_rotr64(((((_rotr64(_rotr64(((_rotr64((_rotr64(reference, 1946645998) + -6082151372269675889LL), 1943309728) ^ -945661854553575642LL) + 2364384438095628184LL), 2082905071), -626287557) ^ -1324004480384476871LL) + -4134283363097677855LL) ^ -1212445195300508517LL) + -2110819659718437961LL), -1015325591) ^ -8096998314023218708LL) ^ 4710472736397951290LL) ^ -2224936177242478907LL) ^ -982217424249473208LL), -1245074767), 1232078422) ^ 2398922226252175537LL), -1668294501), 529913236), 846028966) + 8364455949931124939LL), -39518139) ^ -5356915711319866267LL), -989664586) ^ -7528825972477451373LL) ^ -2122922619825691022LL) + 2685649738752767876LL), -586228080)
#define UNKNOWN_DECRYPT_24(reference) _rotl64((_rotl64(((_rotl64(_rotl64(((((_rotl64(((((_rotl64(_rotl64((_rotr64(_rotl64(_rotl64((_rotl64((_rotr64((((_rotl64(reference, -586228080) - 2685649738752767876LL) ^ -2122922619825691022LL) ^ -7528825972477451373LL), -989664586) ^ -5356915711319866267LL), -39518139) - 8364455949931124939LL), 846028966), 529913236), -1668294501) ^ 2398922226252175537LL), 1232078422), -1245074767) ^ -982217424249473208LL) ^ -2224936177242478907LL) ^ 4710472736397951290LL) ^ -8096998314023218708LL), -1015325591) - -2110819659718437961LL) ^ -1212445195300508517LL) - -4134283363097677855LL) ^ -1324004480384476871LL), -626287557), 2082905071) - 2364384438095628184LL) ^ -945661854553575642LL), 1943309728) - -6082151372269675889LL), 1946645998)
#define UNKNOWN_ENCRYPT_25(reference) _rotr64(_rotl64((((_rotl64((_rotl64(_rotl64((_rotr64(_rotl64(_rotl64(_rotl64(_rotl64(_rotl64(_rotr64(((_rotl64((_rotl64((_rotl64((_rotr64((((_rotr64(reference, 102656628) ^ 7671074482556842736LL) + 8770339088711132555LL) + -1393201835561866242LL), -105955395) + -4842703346017988709LL), -350064542) ^ 7785240025122622462LL), 196464174) + 6331840722831829551LL), -2102006134) ^ -1183160212325455571LL) + 7219233747311652749LL), 476983163), -102069630), -1696739026), 1539761245), -547530304), -1075268609), 545248128) + -6765396954146777612LL), 782419915), 330075878) + -1645455726532492795LL), -514509302) + 2888967404825102761LL) ^ 3006993236745529242LL) + 6521109461783154464LL), -1667051341), -1130150436)
#define UNKNOWN_DECRYPT_25(reference) _rotl64((((_rotl64((_rotr64((_rotr64((_rotr64(((_rotl64(_rotr64(_rotr64(_rotr64(_rotr64(_rotr64(_rotl64((_rotr64(_rotr64((_rotr64((((_rotr64(_rotl64(reference, -1130150436), -1667051341) - 6521109461783154464LL) ^ 3006993236745529242LL) - 2888967404825102761LL), -514509302) - -1645455726532492795LL), 330075878), 782419915) - -6765396954146777612LL), 545248128), -1075268609), -547530304), 1539761245), -1696739026), -102069630), 476983163) - 7219233747311652749LL) ^ -1183160212325455571LL), -2102006134) - 6331840722831829551LL), 196464174) ^ 7785240025122622462LL), -350064542) - -4842703346017988709LL), -105955395) - -1393201835561866242LL) - 8770339088711132555LL) ^ 7671074482556842736LL), 102656628)
#define UNKNOWN_ENCRYPT_26(reference) _rotr64(_rotr64((((((((((_rotr64(((_rotl64(_rotr64(_rotr64((_rotr64(((_rotl64((_rotl64(_rotl64(_rotl64(_rotr64(_rotl64((_rotr64(reference, -361999906) ^ -3722012115439068575LL), -1121966816), 1776313038), -1540836851), 1076375057), 916092064) ^ 8781086990253558623LL), 1719353050) + -8771807697963711231LL) ^ 3404452993191533148LL), -3962896) ^ -8534951125736212840LL), 221939775), 1526377515), -1954168589) ^ 6715712426122600561LL) + -2816127926071835470LL), -1193212932) ^ -9166521585125082265LL) + 5439269918996451061LL) + -2504756060012164423LL) + -7189603932041495773LL) + 4859333021125738723LL) ^ -2197483440166407771LL) ^ 7424037696778588346LL) + -4137862790117887078LL) + 5846525101084183565LL), 685896337), 1261892427)
#define UNKNOWN_DECRYPT_26(reference) _rotl64((_rotr64(_rotl64(_rotr64(_rotr64(_rotr64((_rotr64(((_rotl64((_rotl64(_rotl64(_rotr64(((_rotl64((((((((((_rotl64(_rotl64(reference, 1261892427), 685896337) - 5846525101084183565LL) - -4137862790117887078LL) ^ 7424037696778588346LL) ^ -2197483440166407771LL) - 4859333021125738723LL) - -7189603932041495773LL) - -2504756060012164423LL) - 5439269918996451061LL) ^ -9166521585125082265LL), -1193212932) - -2816127926071835470LL) ^ 6715712426122600561LL), -1954168589), 1526377515), 221939775) ^ -8534951125736212840LL), -3962896) ^ 3404452993191533148LL) - -8771807697963711231LL), 1719353050) ^ 8781086990253558623LL), 916092064), 1076375057), -1540836851), 1776313038), -1121966816) ^ -3722012115439068575LL), -361999906)
#define UNKNOWN_ENCRYPT_27(reference) ((((((_rotl64(_rotr64((_rotl64(((_rotl64((_rotl64(_rotr64(_rotl64((_rotl64(_rotl64(_rotr64(_rotl64((_rotr64((_rotr64(_rotr64((((reference ^ 1466315638757393241LL) + 1432782916187933151LL) ^ 5353616959430948172LL), 556410374), -1942388503) + 4800454649404542277LL), 277455049) ^ -3696563933832832605LL), -1771723465), -2106087630), 1973883028), 1023641111) + 4688532314708919968LL), 217431061), 589167935), 932867725) ^ 8428071174840481998LL), -1022704540) ^ -7171343366099308032LL) ^ 43799339557164623LL), 1573109437) ^ 8528350530652113695LL), -745848240), -714040358) + 1997627842132051113LL) + 2480259324222847970LL) + 9004085117693203735LL) ^ -8895230515569978579LL) ^ 4752749998391776360LL) ^ 5979619782428542654LL)
#define UNKNOWN_DECRYPT_27(reference) (((_rotl64(_rotl64((_rotl64((_rotr64(_rotl64(_rotr64(_rotr64((_rotr64(_rotl64(_rotr64((_rotr64(((_rotr64((_rotl64(_rotr64(((((((reference ^ 5979619782428542654LL) ^ 4752749998391776360LL) ^ -8895230515569978579LL) - 9004085117693203735LL) - 2480259324222847970LL) - 1997627842132051113LL), -714040358), -745848240) ^ 8528350530652113695LL), 1573109437) ^ 43799339557164623LL) ^ -7171343366099308032LL), -1022704540) ^ 8428071174840481998LL), 932867725), 589167935), 217431061) - 4688532314708919968LL), 1023641111), 1973883028), -2106087630), -1771723465) ^ -3696563933832832605LL), 277455049) - 4800454649404542277LL), -1942388503), 556410374) ^ 5353616959430948172LL) - 1432782916187933151LL) ^ 1466315638757393241LL)
#define UNKNOWN_ENCRYPT_28(reference) _rotr64(((((_rotl64((_rotl64(((_rotr64(_rotl64(((_rotl64(_rotl64(_rotr64(_rotr64(((_rotl64((_rotr64(_rotl64(_rotr64((_rotl64((((reference + 3426218080197519440LL) + -1149735977214075921LL) + -6742875534469627627LL), -1833701833) + -5589713178934995167LL), 1565461721), -1810173947), -263641342) ^ -1970537698577330025LL), 1968328527) + -2769167871190559655LL) ^ 8884190365165577882LL), -320668340), 252542430), -132034793), 179633616) ^ 961478431150186285LL) ^ 351617360646587106LL), 865472923), -1304496372) ^ 7678941875066737695LL) ^ -1410938219974578861LL), 1888265289) ^ -2019023751125600075LL), 1366624965) + -8344127881195902318LL) + 6068804171290759673LL) ^ -2042063218867339877LL) ^ 6080100573559027554LL), -1352696349)
#define UNKNOWN_DECRYPT_28(reference) (((_rotr64((_rotl64(_rotr64(_rotl64((_rotr64(((_rotl64(_rotl64(_rotr64(_rotr64(((_rotr64(_rotl64(((_rotr64((_rotr64(((((_rotl64(reference, -1352696349) ^ 6080100573559027554LL) ^ -2042063218867339877LL) - 6068804171290759673LL) - -8344127881195902318LL), 1366624965) ^ -2019023751125600075LL), 1888265289) ^ -1410938219974578861LL) ^ 7678941875066737695LL), -1304496372), 865472923) ^ 351617360646587106LL) ^ 961478431150186285LL), 179633616), -132034793), 252542430), -320668340) ^ 8884190365165577882LL) - -2769167871190559655LL), 1968328527) ^ -1970537698577330025LL), -263641342), -1810173947), 1565461721) - -5589713178934995167LL), -1833701833) - -6742875534469627627LL) - -1149735977214075921LL) - 3426218080197519440LL)
#define UNKNOWN_ENCRYPT_29(reference) _rotr64(((_rotl64(_rotl64(((((_rotl64(_rotr64(_rotr64(_rotr64((_rotr64((_rotl64(_rotl64((_rotr64((_rotl64(_rotl64((_rotl64(_rotl64(((_rotr64(_rotl64(reference, -1982577119), -1469186158) ^ -7877803562371514961LL) ^ -6736274546076181134LL), -1604085332), 984740381) ^ 8673923966572829653LL), -1975783173), 803172549) + 3990689104244708940LL), 1360171057) + -5795412975542817705LL), 1421308665), 706234397) + 8284493292900389569LL), 1257799973) ^ 2056167758764190527LL), 1250571070), -532199015), -2227343), -1885015591) + -3574281242357303271LL) + 4387764036727368283LL) ^ 4532272451658452519LL) ^ 8246266746815821040LL), -330479263), -475062089) + 1014188757786409384LL) ^ -6117237978259900099LL), -514527216)
#define UNKNOWN_DECRYPT_29(reference) _rotr64(_rotl64(((_rotr64(_rotr64((_rotr64(_rotr64((_rotl64((_rotr64(_rotr64((_rotl64((_rotl64(_rotl64(_rotl64(_rotr64(((((_rotr64(_rotr64(((_rotl64(reference, -514527216) ^ -6117237978259900099LL) - 1014188757786409384LL), -475062089), -330479263) ^ 8246266746815821040LL) ^ 4532272451658452519LL) - 4387764036727368283LL) - -3574281242357303271LL), -1885015591), -2227343), -532199015), 1250571070) ^ 2056167758764190527LL), 1257799973) - 8284493292900389569LL), 706234397), 1421308665) - -5795412975542817705LL), 1360171057) - 3990689104244708940LL), 803172549), -1975783173) ^ 8673923966572829653LL), 984740381), -1604085332) ^ -6736274546076181134LL) ^ -7877803562371514961LL), -1469186158), -1982577119)
#define UNKNOWN_ENCRYPT_30(reference) (_rotr64(_rotl64(((_rotr64((_rotr64(_rotl64(((_rotl64((_rotl64(_rotr64(_rotl64((_rotr64(_rotl64(_rotl64((_rotl64(((((((_rotr64((reference + -4893920233763079546LL), -157506762) ^ 6152108482696413243LL) + -2473141171707696902LL) ^ -3967614182721832642LL) ^ 6387763629970198455LL) + 4021828293125040910LL) + -7239167190398227905LL), -516864893) + 414145439888766943LL), -425691782), 1553026346), -660635006) + -3274178599944547349LL), 1623703648), -921137185), -502364789) + 4368742255770933792LL), 108770629) + 2113412017856064090LL) + 8262517133722039549LL), 1384819655), -50950907) ^ -8783355858743965082LL), -813469396) ^ 3434157450443068358LL) ^ 6946017217372624457LL), -11840292), 232770835) ^ 8418809446151706402LL)
#define UNKNOWN_DECRYPT_30(reference) (_rotl64(((((((_rotr64((_rotr64(_rotr64(_rotl64((_rotr64(_rotl64(_rotr64((_rotr64(((_rotr64(_rotl64((_rotl64(((_rotr64(_rotl64((reference ^ 8418809446151706402LL), 232770835), -11840292) ^ 6946017217372624457LL) ^ 3434157450443068358LL), -813469396) ^ -8783355858743965082LL), -50950907), 1384819655) - 8262517133722039549LL) - 2113412017856064090LL), 108770629) - 4368742255770933792LL), -502364789), -921137185), 1623703648) - -3274178599944547349LL), -660635006), 1553026346), -425691782) - 414145439888766943LL), -516864893) - -7239167190398227905LL) - 4021828293125040910LL) ^ 6387763629970198455LL) ^ -3967614182721832642LL) - -2473141171707696902LL) ^ 6152108482696413243LL), -157506762) - -4893920233763079546LL)
#define UNKNOWN_ENCRYPT_31(reference) _rotr64(_rotl64(_rotr64(_rotl64((_rotr64(_rotr64((_rotl64(_rotr64(_rotr64(_rotr64((_rotl64(((_rotl64((_rotl64(_rotl64((((_rotr64(((_rotr64((((reference + -9074469286450141421LL) ^ -2031774942491878643LL) + 2638614135637018879LL), 1565276168) ^ 2872995228365588051LL) ^ 3540767196447334971LL), 2133216677) ^ 4851610048872899794LL) + -4580543444892279979LL) + -9164484883125180036LL), -1749025470), -2112621915) ^ -2745079685510048255LL), -831972202) + 2218751068500244262LL) ^ -4178620228593345288LL), -599346223) ^ 7124738757893217736LL), -702811769), -1965544839), 1272238280), 914024262) + -5322261671358760692LL), 767950391), -43533670) + -4211625518093223344LL), -1279491585), 974472722), -1002125598), 1645432175)
#define UNKNOWN_DECRYPT_31(reference) (((_rotl64(((_rotl64((((_rotr64(_rotr64((_rotr64(((_rotr64((_rotl64(_rotl64(_rotl64(_rotr64((_rotl64(_rotl64((_rotr64(_rotl64(_rotr64(_rotl64(reference, 1645432175), -1002125598), 974472722), -1279491585) - -4211625518093223344LL), -43533670), 767950391) - -5322261671358760692LL), 914024262), 1272238280), -1965544839), -702811769) ^ 7124738757893217736LL), -599346223) ^ -4178620228593345288LL) - 2218751068500244262LL), -831972202) ^ -2745079685510048255LL), -2112621915), -1749025470) - -9164484883125180036LL) - -4580543444892279979LL) ^ 4851610048872899794LL), 2133216677) ^ 3540767196447334971LL) ^ 2872995228365588051LL), 1565276168) - 2638614135637018879LL) ^ -2031774942491878643LL) - -9074469286450141421LL)
#define UNKNOWN_ENCRYPT_32(reference) _rotl64((_rotl64(_rotl64((_rotl64(_rotr64(_rotl64(((_rotl64(_rotr64(_rotr64((((_rotl64(_rotl64(_rotl64((_rotl64((((_rotl64((((_rotr64(_rotl64(reference, 167845241), 1148693374) + -4509098634021168199LL) + -4407121938035563833LL) + 9149787162205298568LL), -248821423) + 8016177777756603722LL) ^ 4489528113806341871LL) ^ 3562717512554093050LL), 1022303032) + 8802356813238246874LL), 1587657072), 644283024), 1585443118) ^ 5374541201306578869LL) + 3370676756535934712LL) ^ -7137085204063157535LL), 401818824), -325493756), -2029067957) ^ -7533986016171726709LL) ^ -3716893915601169146LL), -1092863389), 1058517753), -725877537) + -1952160813160820303LL), -1223419876), -238650614) ^ 7410986004428614543LL), -1659651342)
#define UNKNOWN_DECRYPT_32(reference) _rotr64(_rotl64((((_rotr64((((_rotr64((_rotr64(_rotr64(_rotr64((((_rotl64(_rotl64(_rotr64(((_rotr64(_rotl64(_rotr64((_rotr64(_rotr64((_rotr64(reference, -1659651342) ^ 7410986004428614543LL), -238650614), -1223419876) - -1952160813160820303LL), -725877537), 1058517753), -1092863389) ^ -3716893915601169146LL) ^ -7533986016171726709LL), -2029067957), -325493756), 401818824) ^ -7137085204063157535LL) - 3370676756535934712LL) ^ 5374541201306578869LL), 1585443118), 644283024), 1587657072) - 8802356813238246874LL), 1022303032) ^ 3562717512554093050LL) ^ 4489528113806341871LL) - 8016177777756603722LL), -248821423) - 9149787162205298568LL) - -4407121938035563833LL) - -4509098634021168199LL), 1148693374), 167845241)
#define UNKNOWN_ENCRYPT_33(reference) _rotr64(_rotl64(_rotr64(_rotr64(_rotl64(_rotl64(_rotr64((_rotr64(_rotr64(_rotr64((_rotl64((_rotr64((_rotl64(_rotr64(_rotl64(((_rotl64((_rotr64(_rotr64(_rotl64(_rotr64((_rotr64((reference + -7736095183718347464LL), -1266090439) ^ 5253452316369203503LL), 1897293007), 176422085), -1194030408), 1085909256) + 9034557530849496513LL), -1409130124) + -1385496329647198853LL) ^ 4691285805967394175LL), -1708188384), 1813171469), 577890437) ^ 1455104147579786987LL), 675600119) + -1853822112113920768LL), 1530065648) + 7838218900082202278LL), 989934121), -633298204), 542651714) ^ 3749406635831052543LL), -427484765), -259152032), -1239960072), 2072628355), 1296528734), -55143541), 735869633)
#define UNKNOWN_DECRYPT_33(reference) (_rotl64((_rotl64(_rotr64(_rotl64(_rotl64((_rotr64(((_rotr64(_rotl64(_rotr64((_rotl64((_rotr64((_rotl64(_rotl64(_rotl64((_rotl64(_rotr64(_rotr64(_rotl64(_rotl64(_rotr64(_rotl64(reference, 735869633), -55143541), 1296528734), 2072628355), -1239960072), -259152032), -427484765) ^ 3749406635831052543LL), 542651714), -633298204), 989934121) - 7838218900082202278LL), 1530065648) - -1853822112113920768LL), 675600119) ^ 1455104147579786987LL), 577890437), 1813171469), -1708188384) ^ 4691285805967394175LL) - -1385496329647198853LL), -1409130124) - 9034557530849496513LL), 1085909256), -1194030408), 176422085), 1897293007) ^ 5253452316369203503LL), -1266090439) - -7736095183718347464LL)
#define UNKNOWN_ENCRYPT_34(reference) _rotr64(_rotl64(((_rotl64(_rotl64(_rotl64(_rotr64(_rotr64((_rotr64(((_rotr64(_rotr64(_rotl64(_rotr64(_rotr64(_rotl64(((_rotl64((_rotr64(_rotl64((((_rotr64(_rotr64(reference, -135102730), 2012189391) ^ 6682838022487118691LL) + 3725741273970074672LL) + -1782213958849359347LL), 1251531822), 1414003248) + 6554513501823414804LL), -1940598162) + 2826210143172766682LL) + 2223200713865988823LL), 1400399859), 1743466544), 364495943), -1044261886), -229049735), -440511824) ^ 709690000119290052LL) ^ 8926945422787702561LL), 66885803) ^ 8104808170572214886LL), -20420952), -156248355), -1007851151), 1603100924), -697560299) + 5815872847266765501LL) + 7992843037898554602LL), 896756297), 44066968)
#define UNKNOWN_DECRYPT_34(reference) _rotl64(_rotl64((((_rotr64(_rotl64((_rotr64(((_rotr64(_rotl64(_rotl64(_rotr64(_rotl64(_rotl64(((_rotl64((_rotl64(_rotl64(_rotr64(_rotr64(_rotr64(((_rotr64(_rotl64(reference, 44066968), 896756297) - 7992843037898554602LL) - 5815872847266765501LL), -697560299), 1603100924), -1007851151), -156248355), -20420952) ^ 8104808170572214886LL), 66885803) ^ 8926945422787702561LL) ^ 709690000119290052LL), -440511824), -229049735), -1044261886), 364495943), 1743466544), 1400399859) - 2223200713865988823LL) - 2826210143172766682LL), -1940598162) - 6554513501823414804LL), 1414003248), 1251531822) - -1782213958849359347LL) - 3725741273970074672LL) ^ 6682838022487118691LL), 2012189391), -135102730)
#define UNKNOWN_ENCRYPT_35(reference) ((_rotr64(_rotl64(((_rotr64(((_rotl64((_rotl64(_rotr64((_rotl64((_rotr64(((((_rotl64(_rotr64(((_rotr64(((_rotl64((reference + -7108832118558686790LL), -694062862) ^ -923349009853062186LL) + 6022452013612914781LL), -2080012631) + -2785450141916709803LL) + -4943878464718347428LL), 602618967), -723794378) + 648885612818986800LL) ^ 7151315515843783104LL) ^ 5207180532615378203LL) + -2754386113545593206LL), -1941277184) ^ 7313023855654435821LL), 1232735650) + 7287981590260637366LL), -512728732), -2022106911) ^ 5323296132893712365LL), 1987881412) ^ -8201257367592482761LL) ^ -2788583051453874808LL), -690106471) ^ -154933261441401234LL) ^ -6723259997701421755LL), -104800559), -951405559) + 7994089759540425323LL) ^ 8357320975603434243LL)
#define UNKNOWN_DECRYPT_35(reference) (_rotr64(((_rotl64(((_rotl64(_rotr64(((((_rotl64((_rotr64((_rotl64(_rotr64((_rotr64(((_rotl64(((_rotr64(_rotl64(((reference ^ 8357320975603434243LL) - 7994089759540425323LL), -951405559), -104800559) ^ -6723259997701421755LL) ^ -154933261441401234LL), -690106471) ^ -2788583051453874808LL) ^ -8201257367592482761LL), 1987881412) ^ 5323296132893712365LL), -2022106911), -512728732) - 7287981590260637366LL), 1232735650) ^ 7313023855654435821LL), -1941277184) - -2754386113545593206LL) ^ 5207180532615378203LL) ^ 7151315515843783104LL) - 648885612818986800LL), -723794378), 602618967) - -4943878464718347428LL) - -2785450141916709803LL), -2080012631) - 6022452013612914781LL) ^ -923349009853062186LL), -694062862) - -7108832118558686790LL)
#define UNKNOWN_ENCRYPT_36(reference) (_rotl64(((_rotr64(_rotl64(_rotl64((_rotr64((_rotl64(_rotr64(_rotr64(_rotr64((((((_rotl64(_rotl64(_rotr64(_rotl64(((_rotr64((_rotl64(_rotl64(_rotr64(reference, 1627401293), 373796990), 1872125238) ^ -38858829474053121LL), 1435497775) + 8062599525215730375LL) ^ 5946526745761765371LL), -2145028947), -1166979344), 486973578), -136091235) + 3292452157118589334LL) ^ 399944750071178538LL) + 2089383160469241425LL) + -1460854460800629025LL) ^ -2798176512012358339LL), 285898418), -2039466069), 1884977789), -1414987913) ^ -2152942320412868918LL), 1773521379) ^ 4057341046766866138LL), -1458440611), -139020351), 258925223) + 4633830673235072206LL) ^ -1240108534767472550LL), 1671449727) + 2824199650400838835LL)
#define UNKNOWN_DECRYPT_36(reference) _rotl64(_rotr64(_rotr64((_rotl64(((_rotr64(_rotl64(_rotr64(_rotr64((((((_rotl64(_rotl64(_rotl64(_rotr64((_rotl64((_rotr64(_rotr64(_rotl64(((_rotr64((reference - 2824199650400838835LL), 1671449727) ^ -1240108534767472550LL) - 4633830673235072206LL), 258925223), -139020351), -1458440611) ^ 4057341046766866138LL), 1773521379) ^ -2152942320412868918LL), -1414987913), 1884977789), -2039466069), 285898418) ^ -2798176512012358339LL) - -1460854460800629025LL) - 2089383160469241425LL) ^ 399944750071178538LL) - 3292452157118589334LL), -136091235), 486973578), -1166979344), -2145028947) ^ 5946526745761765371LL) - 8062599525215730375LL), 1435497775) ^ -38858829474053121LL), 1872125238), 373796990), 1627401293)
#define UNKNOWN_ENCRYPT_37(reference) (_rotl64(_rotr64(_rotr64((_rotl64((_rotl64((((_rotl64(_rotr64(_rotr64((_rotl64(_rotr64(((_rotr64(_rotl64(_rotl64((_rotl64((((_rotr64(_rotr64((reference ^ -5165798112399351001LL), 1605657613), -1217668907) ^ 4732754692069231019LL) ^ 1708551569050957137LL) + 4954691710501807161LL), 1985908348) ^ -2665240631869505813LL), 425736119), -816521928), -520876349) + -7641512035810021698LL) + 3791967349436811461LL), -320496398), -308187039) + 822863274552874023LL), -804771979), 850449693), -717999387) + -5886737375238084228LL) + 6398988403405529381LL) ^ -8338360898022015775LL), 782825619) + -3392321602982278607LL), 481194391) ^ -3065602768759826397LL), -1953753221), 2120951483), -1842782838) ^ 2196407606728124490LL)
#define UNKNOWN_DECRYPT_37(reference) (_rotl64(_rotl64((((_rotr64((_rotr64(_rotr64(_rotl64(((_rotl64(_rotr64((_rotl64(_rotl64(_rotr64((((_rotr64((_rotr64((_rotl64(_rotl64(_rotr64((reference ^ 2196407606728124490LL), -1842782838), 2120951483), -1953753221) ^ -3065602768759826397LL), 481194391) - -3392321602982278607LL), 782825619) ^ -8338360898022015775LL) - 6398988403405529381LL) - -5886737375238084228LL), -717999387), 850449693), -804771979) - 822863274552874023LL), -308187039), -320496398) - 3791967349436811461LL) - -7641512035810021698LL), -520876349), -816521928), 425736119) ^ -2665240631869505813LL), 1985908348) - 4954691710501807161LL) ^ 1708551569050957137LL) ^ 4732754692069231019LL), -1217668907), 1605657613) ^ -5165798112399351001LL)
#define UNKNOWN_ENCRYPT_38(reference) _rotl64(((_rotl64(((_rotr64(_rotr64(_rotr64(((_rotr64(_rotr64(_rotl64(_rotl64((_rotl64((_rotr64((_rotr64(_rotr64(_rotr64((_rotl64(_rotr64(_rotl64((_rotr64(_rotr64(reference, -1498137958), 1074471257) ^ 9099999176324065909LL), -883509377), 1962917916), 713406997) ^ 7884495834663155688LL), 1981285050), -2092159861), 1598739023) + 1827916401700379164LL), -2026850305) + 525387636873581529LL), 2050671183) ^ 5570617864566954639LL), 1068872713), 267684114), -402236049), 1133265523) + -7764624386359736926LL) ^ -8669523456708984287LL), 548569094), 372433447), -264622251) ^ -9126197718652876825LL) + -8122074828905428856LL), 1594913907) + -7733513088538199850LL) + -5278458831416213261LL), 217328048)
#define UNKNOWN_DECRYPT_38(reference) _rotl64(_rotl64((_rotr64(_rotl64(_rotr64((_rotl64(_rotl64(_rotl64((_rotl64((_rotr64((_rotr64(_rotr64(_rotl64(_rotl64(((_rotl64(_rotl64(_rotl64(((_rotr64(((_rotr64(reference, 217328048) - -5278458831416213261LL) - -7733513088538199850LL), 1594913907) - -8122074828905428856LL) ^ -9126197718652876825LL), -264622251), 372433447), 548569094) ^ -8669523456708984287LL) - -7764624386359736926LL), 1133265523), -402236049), 267684114), 1068872713) ^ 5570617864566954639LL), 2050671183) - 525387636873581529LL), -2026850305) - 1827916401700379164LL), 1598739023), -2092159861), 1981285050) ^ 7884495834663155688LL), 713406997), 1962917916), -883509377) ^ 9099999176324065909LL), 1074471257), -1498137958)
#define UNKNOWN_ENCRYPT_39(reference) _rotl64(_rotr64((_rotl64(_rotl64(_rotl64((_rotr64(((_rotr64(_rotl64(_rotr64(_rotr64(_rotr64(((_rotl64(_rotl64(((_rotr64((_rotl64(_rotl64((((_rotl64(_rotl64(reference, -1932956753), 2037735200) + -2321905752955530982LL) ^ -7536022016120168807LL) + 107619624335733498LL), 687474243), -111066285) + 5229500693246845699LL), -72799269) ^ -1269014432390422906LL) ^ 8030055055528414570LL), 672948929), -795154638) ^ 4499490887084689275LL) ^ 3896935625695210003LL), 1905187935), 449423049), 349395458), 2133044181), -436364946) ^ -1584154345839061980LL) ^ 6542281204487081225LL), -630733526) ^ 1230377072629581337LL), 546493623), -1724919932), -1747990525) ^ 4258388145973853477LL), 1781905861), 1735780136)
#define UNKNOWN_DECRYPT_39(reference) _rotr64(_rotr64((((_rotr64(_rotr64((_rotl64(((_rotr64(_rotr64(((_rotl64(_rotl64(_rotl64(_rotr64(_rotl64(((_rotl64((_rotr64(_rotr64(_rotr64((_rotl64(_rotr64(reference, 1735780136), 1781905861) ^ 4258388145973853477LL), -1747990525), -1724919932), 546493623) ^ 1230377072629581337LL), -630733526) ^ 6542281204487081225LL) ^ -1584154345839061980LL), -436364946), 2133044181), 349395458), 449423049), 1905187935) ^ 3896935625695210003LL) ^ 4499490887084689275LL), -795154638), 672948929) ^ 8030055055528414570LL) ^ -1269014432390422906LL), -72799269) - 5229500693246845699LL), -111066285), 687474243) - 107619624335733498LL) ^ -7536022016120168807LL) - -2321905752955530982LL), 2037735200), -1932956753)


static jint CurrentVersion = JNI_VERSION_21;

#if defined(_WIN32) && !defined(USE_VECTORED_EXCEPTION_HANDLING)
extern LONG WINAPI topLevelExceptionFilter(_EXCEPTION_POINTERS* );
#endif

// The DT_RETURN_MARK macros create a scoped object to fire the dtrace
// '-return' probe regardless of the return path is taken out of the function.
// Methods that have multiple return paths use this to avoid having to
// instrument each return path.  Methods that use CHECK or THROW must use this
// since those macros can cause an immediate uninstrumented return.
//
// In order to get the return value, a reference to the variable containing
// the return value must be passed to the constructor of the object, and
// the return value must be set before return (since the mark object has
// a reference to it).
//
// Example:
// DT_RETURN_MARK_DECL(SomeFunc, int);
// JNI_ENTRY(int, SomeFunc, ...)
//   int return_value = 0;
//   DT_RETURN_MARK(SomeFunc, int, (const int&)return_value);
//   foo(CHECK_0)
//   return_value = 5;
//   return return_value;
// JNI_END
#define DT_RETURN_MARK_DECL(name, type, probe)                             \
  DTRACE_ONLY(                                                             \
    class DTraceReturnProbeMark_##name {                                   \
     public:                                                               \
      const type& _ret_ref;                                                \
      DTraceReturnProbeMark_##name(const type& v) : _ret_ref(v) {}         \
      ~DTraceReturnProbeMark_##name() {                                    \
        probe;                                                             \
      }                                                                    \
    }                                                                      \
  )
// Void functions are simpler since there's no return value
#define DT_VOID_RETURN_MARK_DECL(name, probe)                              \
  DTRACE_ONLY(                                                             \
    class DTraceReturnProbeMark_##name {                                   \
     public:                                                               \
      ~DTraceReturnProbeMark_##name() {                                    \
        probe;                                                             \
      }                                                                    \
    }                                                                      \
  )

// Place these macros in the function to mark the return.  Non-void
// functions need the type and address of the return value.
#define DT_RETURN_MARK(name, type, ref) \
  DTRACE_ONLY( DTraceReturnProbeMark_##name dtrace_return_mark(ref) )
#define DT_VOID_RETURN_MARK(name) \
  DTRACE_ONLY( DTraceReturnProbeMark_##name dtrace_return_mark )


// Use these to select distinct code for floating-point vs. non-floating point
// situations.  Used from within common macros where we need slightly
// different behavior for Float/Double
#define FP_SELECT_Boolean(intcode, fpcode) intcode
#define FP_SELECT_Byte(intcode, fpcode)    intcode
#define FP_SELECT_Char(intcode, fpcode)    intcode
#define FP_SELECT_Short(intcode, fpcode)   intcode
#define FP_SELECT_Object(intcode, fpcode)  intcode
#define FP_SELECT_Int(intcode, fpcode)     intcode
#define FP_SELECT_Long(intcode, fpcode)    intcode
#define FP_SELECT_Float(intcode, fpcode)   fpcode
#define FP_SELECT_Double(intcode, fpcode)  fpcode
#define FP_SELECT(TypeName, intcode, fpcode) \
  FP_SELECT_##TypeName(intcode, fpcode)

// Choose DT_RETURN_MARK macros  based on the type: float/double -> void
// (dtrace doesn't do FP yet)
#define DT_RETURN_MARK_DECL_FOR(TypeName, name, type, probe)    \
  FP_SELECT(TypeName, \
    DT_RETURN_MARK_DECL(name, type, probe), DT_VOID_RETURN_MARK_DECL(name, probe) )
#define DT_RETURN_MARK_FOR(TypeName, name, type, ref) \
  FP_SELECT(TypeName, \
    DT_RETURN_MARK(name, type, ref), DT_VOID_RETURN_MARK(name) )


// out-of-line helpers for class jfieldIDWorkaround:

bool jfieldIDWorkaround::is_valid_jfieldID(Klass* k, jfieldID id) {
  if (jfieldIDWorkaround::is_instance_jfieldID(k, id)) {
    uintptr_t as_uint = (uintptr_t) id;
    int offset = raw_instance_offset(id);
    if (is_checked_jfieldID(id)) {
      if (!klass_hash_ok(k, id)) {
        return false;
      }
    }
    return InstanceKlass::cast(k)->contains_field_offset(offset);
  } else {
    JNIid* result = (JNIid*) id;
#ifdef ASSERT
    return result != nullptr && result->is_static_field_id();
#else
    return result != nullptr;
#endif
  }
}


intptr_t jfieldIDWorkaround::encode_klass_hash(Klass* k, int offset) {
  if (offset <= small_offset_mask) {
    Klass* field_klass = k;
    Klass* super_klass = field_klass->super();
    // With compressed oops the most super class with nonstatic fields would
    // be the owner of fields embedded in the header.
    while (InstanceKlass::cast(super_klass)->has_nonstatic_fields() &&
           InstanceKlass::cast(super_klass)->contains_field_offset(offset)) {
      field_klass = super_klass;   // super contains the field also
      super_klass = field_klass->super();
    }
    debug_only(NoSafepointVerifier nosafepoint;)
    uintptr_t klass_hash = field_klass->identity_hash();
    return ((klass_hash & klass_mask) << klass_shift) | checked_mask_in_place;
  } else {
#if 0
    #ifndef PRODUCT
    {
      ResourceMark rm;
      warning("VerifyJNIFields: long offset %d in %s", offset, k->external_name());
    }
    #endif
#endif
    return 0;
  }
}

bool jfieldIDWorkaround::klass_hash_ok(Klass* k, jfieldID id) {
  uintptr_t as_uint = (uintptr_t) id;
  intptr_t klass_hash = (as_uint >> klass_shift) & klass_mask;
  do {
    debug_only(NoSafepointVerifier nosafepoint;)
    // Could use a non-blocking query for identity_hash here...
    if ((k->identity_hash() & klass_mask) == klass_hash)
      return true;
    k = k->super();
  } while (k != nullptr);
  return false;
}

void jfieldIDWorkaround::verify_instance_jfieldID(Klass* k, jfieldID id) {
  guarantee(jfieldIDWorkaround::is_instance_jfieldID(k, id), "must be an instance field" );
  uintptr_t as_uint = (uintptr_t) id;
  int offset = raw_instance_offset(id);
  if (VerifyJNIFields) {
    if (is_checked_jfieldID(id)) {
      guarantee(klass_hash_ok(k, id),
    "Bug in native code: jfieldID class must match object");
    } else {
#if 0
      #ifndef PRODUCT
      if (Verbose) {
  ResourceMark rm;
  warning("VerifyJNIFields: unverified offset %d for %s", offset, k->external_name());
      }
      #endif
#endif
    }
  }
  guarantee(InstanceKlass::cast(k)->contains_field_offset(offset),
      "Bug in native code: jfieldID offset must address interior of object");
}

// Implementation of JNI entries

DT_RETURN_MARK_DECL(DefineClass, jclass
                    , HOTSPOT_JNI_DEFINECLASS_RETURN(_ret_ref));

JNI_ENTRY(jclass, jni_DefineClass(JNIEnv *env, const char *name, jobject loaderRef,
                                  const jbyte *buf, jsize bufLen))
  HOTSPOT_JNI_DEFINECLASS_ENTRY(
    env, (char*) name, loaderRef, (char*) buf, bufLen);

  jclass cls = nullptr;
  DT_RETURN_MARK(DefineClass, jclass, (const jclass&)cls);

  // Class resolution will get the class name from the .class stream if the name is null.
  TempNewSymbol class_name = name == nullptr ? nullptr :
    SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_NoClassDefFoundError(),
                                        CHECK_NULL);

  ResourceMark rm(THREAD);
  ClassFileStream st((u1*)buf, bufLen, nullptr, ClassFileStream::verify);
  Handle class_loader (THREAD, JNIHandles::resolve(loaderRef));
  Handle protection_domain;
  ClassLoadInfo cl_info(protection_domain);
  Klass* k = SystemDictionary::resolve_from_stream(&st, class_name,
                                                   class_loader,
                                                   cl_info,
                                                   CHECK_NULL);

  if (log_is_enabled(Debug, class, resolve)) {
    trace_class_resolution(k);
  }

  cls = (jclass)JNIHandles::make_local(THREAD, k->java_mirror());
  return cls;
JNI_END



DT_RETURN_MARK_DECL(FindClass, jclass
                    , HOTSPOT_JNI_FINDCLASS_RETURN(_ret_ref));

JNI_ENTRY(jclass, jni_FindClass(JNIEnv *env, const char *name))
  HOTSPOT_JNI_FINDCLASS_ENTRY(env, (char *)name);

  jclass result = nullptr;
  DT_RETURN_MARK(FindClass, jclass, (const jclass&)result);

  // This should be ClassNotFoundException imo.
  TempNewSymbol class_name =
    SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_NoClassDefFoundError(),
                                        CHECK_NULL);

  //%note jni_3
  Handle protection_domain;
  // Find calling class
  Klass* k = thread->security_get_caller_class(0);
  // default to the system loader when no context
  Handle loader(THREAD, SystemDictionary::java_system_loader());
  if (k != nullptr) {
    // Special handling to make sure JNI_OnLoad and JNI_OnUnload are executed
    // in the correct class context.
    if (k->class_loader() == nullptr &&
        k->name() == vmSymbols::jdk_internal_loader_NativeLibraries()) {
      JavaValue result(T_OBJECT);
      JavaCalls::call_static(&result, k,
                             vmSymbols::getFromClass_name(),
                             vmSymbols::void_class_signature(),
                             CHECK_NULL);
      // When invoked from JNI_OnLoad, NativeLibraries::getFromClass returns
      // a non-null Class object.  When invoked from JNI_OnUnload,
      // it will return null to indicate no context.
      oop mirror = result.get_oop();
      if (mirror != nullptr) {
        Klass* fromClass = java_lang_Class::as_Klass(mirror);
        loader = Handle(THREAD, fromClass->class_loader());
        protection_domain = Handle(THREAD, fromClass->protection_domain());
      }
    } else {
      loader = Handle(THREAD, k->class_loader());
    }
  }

  result = find_class_from_class_loader(env, class_name, true, loader,
                                        protection_domain, true, thread);

  if (log_is_enabled(Debug, class, resolve) && result != nullptr) {
    trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
  }

  return result;
JNI_END

DT_RETURN_MARK_DECL(FromReflectedMethod, jmethodID
                    , HOTSPOT_JNI_FROMREFLECTEDMETHOD_RETURN((uintptr_t)_ret_ref));

JNI_ENTRY(jmethodID, jni_FromReflectedMethod(JNIEnv *env, jobject method))
  HOTSPOT_JNI_FROMREFLECTEDMETHOD_ENTRY(env, method);

  jmethodID ret = nullptr;
  DT_RETURN_MARK(FromReflectedMethod, jmethodID, (const jmethodID&)ret);

  // method is a handle to a java.lang.reflect.Method object
  oop reflected  = JNIHandles::resolve_non_null(method);
  oop mirror     = nullptr;
  int slot       = 0;

  if (reflected->klass() == vmClasses::reflect_Constructor_klass()) {
    mirror = java_lang_reflect_Constructor::clazz(reflected);
    slot   = java_lang_reflect_Constructor::slot(reflected);
  } else {
    assert(reflected->klass() == vmClasses::reflect_Method_klass(), "wrong type");
    mirror = java_lang_reflect_Method::clazz(reflected);
    slot   = java_lang_reflect_Method::slot(reflected);
  }
  Klass* k1 = java_lang_Class::as_Klass(mirror);

  // Make sure class is initialized before handing id's out to methods
  k1->initialize(CHECK_NULL);
  Method* m = InstanceKlass::cast(k1)->method_with_idnum(slot);
  ret = m==nullptr? nullptr : m->jmethod_id();  // return null if reflected method deleted
  return ret;
JNI_END

DT_RETURN_MARK_DECL(FromReflectedField, jfieldID
                    , HOTSPOT_JNI_FROMREFLECTEDFIELD_RETURN((uintptr_t)_ret_ref));

JNI_ENTRY(jfieldID, jni_FromReflectedField(JNIEnv *env, jobject field))
  HOTSPOT_JNI_FROMREFLECTEDFIELD_ENTRY(env, field);

  jfieldID ret = nullptr;
  DT_RETURN_MARK(FromReflectedField, jfieldID, (const jfieldID&)ret);

  // field is a handle to a java.lang.reflect.Field object
  oop reflected   = JNIHandles::resolve_non_null(field);
  oop mirror      = java_lang_reflect_Field::clazz(reflected);
  Klass* k1       = java_lang_Class::as_Klass(mirror);
  int slot        = java_lang_reflect_Field::slot(reflected);
  int modifiers   = java_lang_reflect_Field::modifiers(reflected);

  // Make sure class is initialized before handing id's out to fields
  k1->initialize(CHECK_NULL);

  // First check if this is a static field
  if (modifiers & JVM_ACC_STATIC) {
    int offset = InstanceKlass::cast(k1)->field_offset( slot );
    JNIid* id = InstanceKlass::cast(k1)->jni_id_for(offset);
    assert(id != nullptr, "corrupt Field object");
    debug_only(id->set_is_static_field_id();)
    // A jfieldID for a static field is a JNIid specifying the field holder and the offset within the Klass*
    ret = jfieldIDWorkaround::to_static_jfieldID(id);
    return ret;
  }

  // The slot is the index of the field description in the field-array
  // The jfieldID is the offset of the field within the object
  // It may also have hash bits for k, if VerifyJNIFields is turned on.
  int offset = InstanceKlass::cast(k1)->field_offset( slot );
  assert(InstanceKlass::cast(k1)->contains_field_offset(offset), "stay within object");
  ret = jfieldIDWorkaround::to_instance_jfieldID(k1, offset);
  return ret;
JNI_END


DT_RETURN_MARK_DECL(ToReflectedMethod, jobject
                    , HOTSPOT_JNI_TOREFLECTEDMETHOD_RETURN(_ret_ref));

JNI_ENTRY(jobject, jni_ToReflectedMethod(JNIEnv *env, jclass cls, jmethodID method_id, jboolean isStatic))
  HOTSPOT_JNI_TOREFLECTEDMETHOD_ENTRY(env, cls, (uintptr_t) method_id, isStatic);

  jobject ret = nullptr;
  DT_RETURN_MARK(ToReflectedMethod, jobject, (const jobject&)ret);

  methodHandle m (THREAD, Method::resolve_jmethod_id(method_id));
  assert(m->is_static() == (isStatic != 0), "jni_ToReflectedMethod access flags doesn't match");
  oop reflection_method;
  if (m->is_initializer()) {
    reflection_method = Reflection::new_constructor(m, CHECK_NULL);
  } else {
    reflection_method = Reflection::new_method(m, false, CHECK_NULL);
  }
  ret = JNIHandles::make_local(THREAD, reflection_method);
  return ret;
JNI_END

DT_RETURN_MARK_DECL(GetSuperclass, jclass
                    , HOTSPOT_JNI_GETSUPERCLASS_RETURN(_ret_ref));

JNI_ENTRY(jclass, jni_GetSuperclass(JNIEnv *env, jclass sub))
  HOTSPOT_JNI_GETSUPERCLASS_ENTRY(env, sub);

  jclass obj = nullptr;
  DT_RETURN_MARK(GetSuperclass, jclass, (const jclass&)obj);

  oop mirror = JNIHandles::resolve_non_null(sub);
  // primitive classes return null
  if (java_lang_Class::is_primitive(mirror)) return nullptr;

  // Rules of Class.getSuperClass as implemented by KLass::java_super:
  // arrays return Object
  // interfaces return null
  // proper classes return Klass::super()
  Klass* k = java_lang_Class::as_Klass(mirror);
  if (k->is_interface()) return nullptr;

  // return mirror for superclass
  Klass* super = k->java_super();
  // super2 is the value computed by the compiler's getSuperClass intrinsic:
  debug_only(Klass* super2 = ( k->is_array_klass()
                                 ? vmClasses::Object_klass()
                                 : k->super() ) );
  assert(super == super2,
         "java_super computation depends on interface, array, other super");
  obj = (super == nullptr) ? nullptr : (jclass) JNIHandles::make_local(THREAD, super->java_mirror());
  return obj;
JNI_END

JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsAssignableFrom(JNIEnv *env, jclass sub, jclass super))
  HOTSPOT_JNI_ISASSIGNABLEFROM_ENTRY(env, sub, super);

  oop sub_mirror   = JNIHandles::resolve_non_null(sub);
  oop super_mirror = JNIHandles::resolve_non_null(super);
  if (java_lang_Class::is_primitive(sub_mirror) ||
      java_lang_Class::is_primitive(super_mirror)) {
    jboolean ret = (sub_mirror == super_mirror);

    HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
    return ret;
  }
  Klass* sub_klass   = java_lang_Class::as_Klass(sub_mirror);
  Klass* super_klass = java_lang_Class::as_Klass(super_mirror);
  assert(sub_klass != nullptr && super_klass != nullptr, "invalid arguments to jni_IsAssignableFrom");
  jboolean ret = sub_klass->is_subtype_of(super_klass) ?
                   JNI_TRUE : JNI_FALSE;

  HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
  return ret;
JNI_END


DT_RETURN_MARK_DECL(Throw, jint
                    , HOTSPOT_JNI_THROW_RETURN(_ret_ref));

JNI_ENTRY(jint, jni_Throw(JNIEnv *env, jthrowable obj))
  HOTSPOT_JNI_THROW_ENTRY(env, obj);

  jint ret = JNI_OK;
  DT_RETURN_MARK(Throw, jint, (const jint&)ret);

  THROW_OOP_(JNIHandles::resolve(obj), JNI_OK);
  ShouldNotReachHere();
  return 0;  // Mute compiler.
JNI_END


DT_RETURN_MARK_DECL(ThrowNew, jint
                    , HOTSPOT_JNI_THROWNEW_RETURN(_ret_ref));

JNI_ENTRY(jint, jni_ThrowNew(JNIEnv *env, jclass clazz, const char *message))
  HOTSPOT_JNI_THROWNEW_ENTRY(env, clazz, (char *) message);

  jint ret = JNI_OK;
  DT_RETURN_MARK(ThrowNew, jint, (const jint&)ret);

  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
  Symbol*  name = k->name();
  Handle class_loader (THREAD,  k->class_loader());
  Handle protection_domain (THREAD, k->protection_domain());
  THROW_MSG_LOADER_(name, (char *)message, class_loader, protection_domain, JNI_OK);
  ShouldNotReachHere();
  return 0;  // Mute compiler.
JNI_END


// JNI functions only transform a pending async exception to a synchronous
// exception in ExceptionOccurred and ExceptionCheck calls, since
// delivering an async exception in other places won't change the native
// code's control flow and would be harmful when native code further calls
// JNI functions with a pending exception. Async exception is also checked
// during the call, so ExceptionOccurred/ExceptionCheck won't return
// false but deliver the async exception at the very end during
// state transition.

static void jni_check_async_exceptions(JavaThread *thread) {
  assert(thread == Thread::current(), "must be itself");
  if (thread->has_async_exception_condition()) {
    SafepointMechanism::process_if_requested_with_exit_check(thread, true /* check asyncs */);
  }
}

JNI_ENTRY_NO_PRESERVE(jthrowable, jni_ExceptionOccurred(JNIEnv *env))
  HOTSPOT_JNI_EXCEPTIONOCCURRED_ENTRY(env);

  jni_check_async_exceptions(thread);
  oop exception = thread->pending_exception();
  jthrowable ret = (jthrowable) JNIHandles::make_local(THREAD, exception);

  HOTSPOT_JNI_EXCEPTIONOCCURRED_RETURN(ret);
  return ret;
JNI_END


JNI_ENTRY_NO_PRESERVE(void, jni_ExceptionDescribe(JNIEnv *env))
  HOTSPOT_JNI_EXCEPTIONDESCRIBE_ENTRY(env);

  if (thread->has_pending_exception()) {
    Handle ex(thread, thread->pending_exception());
    thread->clear_pending_exception();
    jio_fprintf(defaultStream::error_stream(), "Exception ");
    if (thread != nullptr && thread->threadObj() != nullptr) {
      ResourceMark rm(THREAD);
      jio_fprintf(defaultStream::error_stream(),
                  "in thread \"%s\" ", thread->name());
    }
    if (ex->is_a(vmClasses::Throwable_klass())) {
      JavaValue result(T_VOID);
      JavaCalls::call_virtual(&result,
                              ex,
                              vmClasses::Throwable_klass(),
                              vmSymbols::printStackTrace_name(),
                              vmSymbols::void_method_signature(),
                              THREAD);
      // If an exception is thrown in the call it gets thrown away. Not much
      // we can do with it. The native code that calls this, does not check
      // for the exception - hence, it might still be in the thread when DestroyVM gets
      // called, potentially causing a few asserts to trigger - since no pending exception
      // is expected.
      CLEAR_PENDING_EXCEPTION;
    } else {
      ResourceMark rm(THREAD);
      jio_fprintf(defaultStream::error_stream(),
                  ". Uncaught exception of type %s.",
                  ex->klass()->external_name());
    }
  }

  HOTSPOT_JNI_EXCEPTIONDESCRIBE_RETURN();
JNI_END


JNI_ENTRY_NO_PRESERVE(void, jni_ExceptionClear(JNIEnv *env))
  HOTSPOT_JNI_EXCEPTIONCLEAR_ENTRY(env);

  // The jni code might be using this API to clear java thrown exception.
  // So just mark jvmti thread exception state as exception caught.
  JvmtiThreadState *state = JavaThread::current()->jvmti_thread_state();
  if (state != nullptr && state->is_exception_detected()) {
    state->set_exception_caught();
  }
  thread->clear_pending_exception();

  HOTSPOT_JNI_EXCEPTIONCLEAR_RETURN();
JNI_END


JNI_ENTRY(void, jni_FatalError(JNIEnv *env, const char *msg))
  HOTSPOT_JNI_FATALERROR_ENTRY(env, (char *) msg);

  tty->print_cr("FATAL ERROR in native method: %s", msg);
  thread->print_jni_stack();
  os::abort(); // Dump core and abort
JNI_END


JNI_ENTRY(jint, jni_PushLocalFrame(JNIEnv *env, jint capacity))
  HOTSPOT_JNI_PUSHLOCALFRAME_ENTRY(env, capacity);

  //%note jni_11
  if (capacity < 0 ||
      ((MaxJNILocalCapacity > 0) && (capacity > MaxJNILocalCapacity))) {
    HOTSPOT_JNI_PUSHLOCALFRAME_RETURN((uint32_t)JNI_ERR);
    return JNI_ERR;
  }

  thread->push_jni_handle_block();
  jint ret = JNI_OK;
  HOTSPOT_JNI_PUSHLOCALFRAME_RETURN(ret);
  return ret;
JNI_END


JNI_ENTRY(jobject, jni_PopLocalFrame(JNIEnv *env, jobject result))
  HOTSPOT_JNI_POPLOCALFRAME_ENTRY(env, result);

  //%note jni_11
  Handle result_handle(thread, JNIHandles::resolve(result));
  JNIHandleBlock* old_handles = thread->active_handles();
  JNIHandleBlock* new_handles = old_handles->pop_frame_link();
  if (new_handles != nullptr) {
    // As a sanity check we only release the handle blocks if the pop_frame_link is not null.
    // This way code will still work if PopLocalFrame is called without a corresponding
    // PushLocalFrame call. Note that we set the pop_frame_link to null explicitly, otherwise
    // the release_block call will release the blocks.
    thread->set_active_handles(new_handles);
    old_handles->set_pop_frame_link(nullptr);              // clear link we won't release new_handles below
    JNIHandleBlock::release_block(old_handles, thread); // may block
    result = JNIHandles::make_local(thread, result_handle());
  }
  HOTSPOT_JNI_POPLOCALFRAME_RETURN(result);
  return result;
JNI_END


JNI_ENTRY(jobject, jni_NewGlobalRef(JNIEnv *env, jobject ref))
  HOTSPOT_JNI_NEWGLOBALREF_ENTRY(env, ref);

  Handle ref_handle(thread, JNIHandles::resolve(ref));
  jobject ret = JNIHandles::make_global(ref_handle, AllocFailStrategy::RETURN_NULL);

  HOTSPOT_JNI_NEWGLOBALREF_RETURN(ret);
  return ret;
JNI_END

// Must be JNI_ENTRY (with HandleMark)
JNI_ENTRY_NO_PRESERVE(void, jni_DeleteGlobalRef(JNIEnv *env, jobject ref))
  HOTSPOT_JNI_DELETEGLOBALREF_ENTRY(env, ref);

  JNIHandles::destroy_global(ref);

  HOTSPOT_JNI_DELETEGLOBALREF_RETURN();
JNI_END

JNI_ENTRY_NO_PRESERVE(void, jni_DeleteLocalRef(JNIEnv *env, jobject obj))
  HOTSPOT_JNI_DELETELOCALREF_ENTRY(env, obj);

  JNIHandles::destroy_local(obj);

  HOTSPOT_JNI_DELETELOCALREF_RETURN();
JNI_END

JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsSameObject(JNIEnv *env, jobject r1, jobject r2))
  HOTSPOT_JNI_ISSAMEOBJECT_ENTRY(env, r1, r2);

  jboolean ret = JNIHandles::is_same_object(r1, r2) ? JNI_TRUE : JNI_FALSE;

  HOTSPOT_JNI_ISSAMEOBJECT_RETURN(ret);
  return ret;
JNI_END


JNI_ENTRY(jobject, jni_NewLocalRef(JNIEnv *env, jobject ref))
  HOTSPOT_JNI_NEWLOCALREF_ENTRY(env, ref);

  jobject ret = JNIHandles::make_local(THREAD, JNIHandles::resolve(ref),
                                       AllocFailStrategy::RETURN_NULL);

  HOTSPOT_JNI_NEWLOCALREF_RETURN(ret);
  return ret;
JNI_END

JNI_LEAF(jint, jni_EnsureLocalCapacity(JNIEnv *env, jint capacity))
  HOTSPOT_JNI_ENSURELOCALCAPACITY_ENTRY(env, capacity);

  jint ret;
  if (capacity >= 0 &&
      ((MaxJNILocalCapacity <= 0) || (capacity <= MaxJNILocalCapacity))) {
    ret = JNI_OK;
  } else {
    ret = JNI_ERR;
  }

  HOTSPOT_JNI_ENSURELOCALCAPACITY_RETURN(ret);
  return ret;
JNI_END

// Return the Handle Type
JNI_LEAF(jobjectRefType, jni_GetObjectRefType(JNIEnv *env, jobject obj))
  HOTSPOT_JNI_GETOBJECTREFTYPE_ENTRY(env, obj);

  jobjectRefType ret = JNIInvalidRefType;
  if (obj != nullptr) {
    ret = JNIHandles::handle_type(thread, obj);
  }

  HOTSPOT_JNI_GETOBJECTREFTYPE_RETURN((void *) ret);
  return ret;
JNI_END


class JNI_ArgumentPusher : public SignatureIterator {
 protected:
  JavaCallArguments*  _arguments;

  void push_int(jint x)         { _arguments->push_int(x); }
  void push_long(jlong x)       { _arguments->push_long(x); }
  void push_float(jfloat x)     { _arguments->push_float(x); }
  void push_double(jdouble x)   { _arguments->push_double(x); }
  void push_object(jobject x)   { _arguments->push_jobject(x); }

  void push_boolean(jboolean b) {
    // Normalize boolean arguments from native code by converting 1-255 to JNI_TRUE and
    // 0 to JNI_FALSE.  Boolean return values from native are normalized the same in
    // TemplateInterpreterGenerator::generate_result_handler_for and
    // SharedRuntime::generate_native_wrapper.
    push_int(b == 0 ? JNI_FALSE : JNI_TRUE);
  }

  JNI_ArgumentPusher(Method* method)
    : SignatureIterator(method->signature(),
                        Fingerprinter(methodHandle(Thread::current(), method)).fingerprint())
  {
    _arguments = nullptr;
  }

 public:
  virtual void push_arguments_on(JavaCallArguments* arguments) = 0;
};


class JNI_ArgumentPusherVaArg : public JNI_ArgumentPusher {
  va_list _ap;

  void set_ap(va_list rap) {
    va_copy(_ap, rap);
  }

  friend class SignatureIterator;  // so do_parameters_on can call do_type
  void do_type(BasicType type) {
    switch (type) {
    // these are coerced to int when using va_arg
    case T_BYTE:
    case T_CHAR:
    case T_SHORT:
    case T_INT:         push_int(va_arg(_ap, jint)); break;
    case T_BOOLEAN:     push_boolean((jboolean) va_arg(_ap, jint)); break;

    // each of these paths is exercised by the various jck Call[Static,Nonvirtual,][Void,Int,..]Method[A,V,] tests

    case T_LONG:        push_long(va_arg(_ap, jlong)); break;
    // float is coerced to double w/ va_arg
    case T_FLOAT:       push_float((jfloat) va_arg(_ap, jdouble)); break;
    case T_DOUBLE:      push_double(va_arg(_ap, jdouble)); break;

    case T_ARRAY:
    case T_OBJECT:      push_object(va_arg(_ap, jobject)); break;
    default:            ShouldNotReachHere();
    }
  }

 public:
  JNI_ArgumentPusherVaArg(jmethodID method_id, va_list rap)
      : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)) {
    set_ap(rap);
  }

  ~JNI_ArgumentPusherVaArg() {
    va_end(_ap);
  }

  virtual void push_arguments_on(JavaCallArguments* arguments) {
    _arguments = arguments;
    do_parameters_on(this);
  }
};


class JNI_ArgumentPusherArray : public JNI_ArgumentPusher {
 protected:
  const jvalue *_ap;

  inline void set_ap(const jvalue *rap) { _ap = rap; }

  friend class SignatureIterator;  // so do_parameters_on can call do_type
  void do_type(BasicType type) {
    switch (type) {
    case T_CHAR:        push_int((_ap++)->c); break;
    case T_SHORT:       push_int((_ap++)->s); break;
    case T_BYTE:        push_int((_ap++)->b); break;
    case T_INT:         push_int((_ap++)->i); break;
    case T_BOOLEAN:     push_boolean((_ap++)->z); break;
    case T_LONG:        push_long((_ap++)->j); break;
    case T_FLOAT:       push_float((_ap++)->f); break;
    case T_DOUBLE:      push_double((_ap++)->d); break;
    case T_ARRAY:
    case T_OBJECT:      push_object((_ap++)->l); break;
    default:            ShouldNotReachHere();
    }
  }

 public:
  JNI_ArgumentPusherArray(jmethodID method_id, const jvalue *rap)
      : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)) {
    set_ap(rap);
  }

  virtual void push_arguments_on(JavaCallArguments* arguments) {
    _arguments = arguments;
    do_parameters_on(this);
  }
};


enum JNICallType {
  JNI_STATIC,
  JNI_VIRTUAL,
  JNI_NONVIRTUAL
};



static void jni_invoke_static(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
  methodHandle method(THREAD, Method::resolve_jmethod_id(method_id));

  // Create object to hold arguments for the JavaCall, and associate it with
  // the jni parser
  ResourceMark rm(THREAD);
  int number_of_parameters = method->size_of_parameters();
  JavaCallArguments java_args(number_of_parameters);

  assert(method->is_static(), "method should be static");

  // Fill out JavaCallArguments object
  args->push_arguments_on(&java_args);
  // Initialize result type
  result->set_type(args->return_type());

  // Invoke the method. Result is returned as oop.
  JavaCalls::call(result, method, &java_args, CHECK);

  // Convert result
  if (is_reference_type(result->get_type())) {
    result->set_jobject(JNIHandles::make_local(THREAD, result->get_oop()));
  }
}


static void jni_invoke_nonstatic(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
  oop recv = JNIHandles::resolve(receiver);
  if (recv == nullptr) {
    THROW(vmSymbols::java_lang_NullPointerException());
  }
  Handle h_recv(THREAD, recv);

  int number_of_parameters;
  Method* selected_method;
  {
    Method* m = Method::resolve_jmethod_id(method_id);
    number_of_parameters = m->size_of_parameters();
    InstanceKlass* holder = m->method_holder();
    if (call_type != JNI_VIRTUAL) {
        selected_method = m;
    } else if (!m->has_itable_index()) {
      // non-interface call -- for that little speed boost, don't handlize
      debug_only(NoSafepointVerifier nosafepoint;)
      // jni_GetMethodID makes sure class is linked and initialized
      // so m should have a valid vtable index.
      assert(m->valid_vtable_index(), "no valid vtable index");
      int vtbl_index = m->vtable_index();
      if (vtbl_index != Method::nonvirtual_vtable_index) {
        selected_method = h_recv->klass()->method_at_vtable(vtbl_index);
      } else {
        // final method
        selected_method = m;
      }
    } else {
      // interface call
      int itbl_index = m->itable_index();
      Klass* k = h_recv->klass();
      selected_method = InstanceKlass::cast(k)->method_at_itable(holder, itbl_index, CHECK);
    }
  }

  if (selected_method->is_abstract()) {
    ResourceMark rm(THREAD);
    THROW_MSG(vmSymbols::java_lang_AbstractMethodError(), selected_method->name()->as_C_string());
  }

  methodHandle method(THREAD, selected_method);

  // Create object to hold arguments for the JavaCall, and associate it with
  // the jni parser
  ResourceMark rm(THREAD);
  JavaCallArguments java_args(number_of_parameters);

  // handle arguments
  assert(!method->is_static(), "method %s should not be static", method->name_and_sig_as_C_string());
  java_args.push_oop(h_recv); // Push jobject handle

  // Fill out JavaCallArguments object
  args->push_arguments_on(&java_args);
  // Initialize result type
  result->set_type(args->return_type());

  // Invoke the method. Result is returned as oop.
  JavaCalls::call(result, method, &java_args, CHECK);

  // Convert result
  if (is_reference_type(result->get_type())) {
    result->set_jobject(JNIHandles::make_local(THREAD, result->get_oop()));
  }
}

DT_RETURN_MARK_DECL(AllocObject, jobject
                    , HOTSPOT_JNI_ALLOCOBJECT_RETURN(_ret_ref));

JNI_ENTRY(jobject, jni_AllocObject(JNIEnv *env, jclass clazz))
  HOTSPOT_JNI_ALLOCOBJECT_ENTRY(env, clazz);

  jobject ret = nullptr;
  DT_RETURN_MARK(AllocObject, jobject, (const jobject&)ret);

  instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);
  ret = JNIHandles::make_local(THREAD, i);
  return ret;
JNI_END

DT_RETURN_MARK_DECL(NewObjectA, jobject
                    , HOTSPOT_JNI_NEWOBJECTA_RETURN(_ret_ref));

JNI_ENTRY(jobject, jni_NewObjectA(JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args))
  HOTSPOT_JNI_NEWOBJECTA_ENTRY(env, clazz, (uintptr_t) methodID);

  jobject obj = nullptr;
  DT_RETURN_MARK(NewObjectA, jobject, (const jobject&)obj);

  instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);
  obj = JNIHandles::make_local(THREAD, i);
  JavaValue jvalue(T_VOID);
  JNI_ArgumentPusherArray ap(methodID, args);
  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);
  return obj;
JNI_END


DT_RETURN_MARK_DECL(NewObjectV, jobject
                    , HOTSPOT_JNI_NEWOBJECTV_RETURN(_ret_ref));

JNI_ENTRY(jobject, jni_NewObjectV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args))
  HOTSPOT_JNI_NEWOBJECTV_ENTRY(env, clazz, (uintptr_t) methodID);

  jobject obj = nullptr;
  DT_RETURN_MARK(NewObjectV, jobject, (const jobject&)obj);

  instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);
  obj = JNIHandles::make_local(THREAD, i);
  JavaValue jvalue(T_VOID);
  JNI_ArgumentPusherVaArg ap(methodID, args);
  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);
  return obj;
JNI_END


DT_RETURN_MARK_DECL(NewObject, jobject
                    , HOTSPOT_JNI_NEWOBJECT_RETURN(_ret_ref));

JNI_ENTRY(jobject, jni_NewObject(JNIEnv *env, jclass clazz, jmethodID methodID, ...))
  HOTSPOT_JNI_NEWOBJECT_ENTRY(env, clazz, (uintptr_t) methodID);

  jobject obj = nullptr;
  DT_RETURN_MARK(NewObject, jobject, (const jobject&)obj);

  instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);
  obj = JNIHandles::make_local(THREAD, i);
  va_list args;
  va_start(args, methodID);
  JavaValue jvalue(T_VOID);
  JNI_ArgumentPusherVaArg ap(methodID, args);
  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);
  va_end(args);
  return obj;
JNI_END


JNI_ENTRY(jclass, jni_GetObjectClass(JNIEnv *env, jobject obj))
  HOTSPOT_JNI_GETOBJECTCLASS_ENTRY(env, obj);

  Klass* k = JNIHandles::resolve_non_null(obj)->klass();
  jclass ret =
    (jclass) JNIHandles::make_local(THREAD, k->java_mirror());

  HOTSPOT_JNI_GETOBJECTCLASS_RETURN(ret);
  return ret;
JNI_END

JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsInstanceOf(JNIEnv *env, jobject obj, jclass clazz))
  HOTSPOT_JNI_ISINSTANCEOF_ENTRY(env, obj, clazz);

  jboolean ret = JNI_TRUE;
  if (obj != nullptr) {
    ret = JNI_FALSE;
    Klass* k = java_lang_Class::as_Klass(
      JNIHandles::resolve_non_null(clazz));
    if (k != nullptr) {
      ret = JNIHandles::resolve_non_null(obj)->is_a(k) ? JNI_TRUE : JNI_FALSE;
    }
  }

  HOTSPOT_JNI_ISINSTANCEOF_RETURN(ret);
  return ret;
JNI_END


static jmethodID get_method_id(JNIEnv *env, jclass clazz, const char *name_str,
                               const char *sig, bool is_static, TRAPS) {
  // %%%% This code should probably just call into a method in the LinkResolver
  //
  // The class should have been loaded (we have an instance of the class
  // passed in) so the method and signature should already be in the symbol
  // table.  If they're not there, the method doesn't exist.
  const char *name_to_probe = (name_str == nullptr)
                        ? vmSymbols::object_initializer_name()->as_C_string()
                        : name_str;
  TempNewSymbol name = SymbolTable::probe(name_to_probe, (int)strlen(name_to_probe));
  TempNewSymbol signature = SymbolTable::probe(sig, (int)strlen(sig));

  if (name == nullptr || signature == nullptr) {
    THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), name_str);
  }

  oop mirror = JNIHandles::resolve_non_null(clazz);
  Klass* klass = java_lang_Class::as_Klass(mirror);

  // Throw a NoSuchMethodError exception if we have an instance of a
  // primitive java.lang.Class
  if (java_lang_Class::is_primitive(mirror)) {
    ResourceMark rm(THREAD);
    THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), err_msg("%s%s.%s%s", is_static ? "static " : "", klass->signature_name(), name_str, sig));
  }

  // Make sure class is linked and initialized before handing id's out to
  // Method*s.
  klass->initialize(CHECK_NULL);

  Method* m;
  if (name == vmSymbols::object_initializer_name() ||
      name == vmSymbols::class_initializer_name()) {
    // Never search superclasses for constructors
    if (klass->is_instance_klass()) {
      m = InstanceKlass::cast(klass)->find_method(name, signature);
    } else {
      m = nullptr;
    }
  } else {
    m = klass->lookup_method(name, signature);
    if (m == nullptr &&  klass->is_instance_klass()) {
      m = InstanceKlass::cast(klass)->lookup_method_in_ordered_interfaces(name, signature);
    }
  }
  if (m == nullptr || (m->is_static() != is_static)) {
    ResourceMark rm(THREAD);
    THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), err_msg("%s%s.%s%s", is_static ? "static " : "", klass->signature_name(), name_str, sig));
  }
  return m->jmethod_id();
}


JNI_ENTRY(jmethodID, jni_NaebalovoGetMethodID(JNIEnv* env, jclass clazz,
    const char* name, const char* sig))
    jmethodID ret = get_method_id(env, clazz, (char*)name, sig, false, thread);
return ret;
JNI_END

JNI_ENTRY(jmethodID, jni_GetMethodID(JNIEnv * env, jclass clazz,
    const char* name, const char* sig))
    HOTSPOT_JNI_GETMETHODID_ENTRY(env, clazz, (char*)name, (char*)sig);
jmethodID ret = get_method_id(env, clazz, (char*)name, sig, false, thread);
HOTSPOT_JNI_GETMETHODID_RETURN((uintptr_t)ret);
return ret;
JNI_END


JNI_ENTRY(jmethodID, jni_GetStaticMethodID(JNIEnv * env, jclass clazz,
    const char* name, const char* sig))
    HOTSPOT_JNI_GETSTATICMETHODID_ENTRY(env, (char*)clazz, (char*)name, (char*)sig);
jmethodID ret = get_method_id(env, clazz, (char*)name, sig, true, thread);
HOTSPOT_JNI_GETSTATICMETHODID_RETURN((uintptr_t)ret);
return ret;
JNI_END


JNI_ENTRY(jmethodID, jni_NaebalovoGetStaticMethodID(JNIEnv * env, jclass clazz,
    const char* name, const char* sig))
    jmethodID ret = get_method_id(env, clazz, (char*)name, sig, true, thread);
return ret;
JNI_END



//
// Calling Methods
//

#define DEFINE_NAEBALOVOCALLMETHOD(ResultType, Result, Tag \
                          , EntryProbe, ReturnProbe)    \
\
  DT_RETURN_MARK_DECL_FOR(Result, Call##Result##Method, ResultType \
                          , ReturnProbe);                          \
\
JNI_ENTRY(ResultType, \
          jni_NaebalovoCall##Result##Method(JNIEnv *env, jobject obj, jmethodID methodID, ...)) \
\
  EntryProbe; \
  ResultType ret = 0;\
  DT_RETURN_MARK_FOR(Result, Call##Result##Method, ResultType, \
                     (const ResultType&)ret);\
\
  va_list args; \
  va_start(args, methodID); \
  JavaValue jvalue(Tag); \
  JNI_ArgumentPusherVaArg ap(methodID, args); \
  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_0); \
  va_end(args); \
  ret = jvalue.get_##ResultType(); \
  return ret;\
JNI_END

// the runtime type of subword integral basic types is integer
DEFINE_NAEBALOVOCALLMETHOD(jboolean, Boolean, T_BOOLEAN
    , HOTSPOT_JNI_CALLBOOLEANMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
    HOTSPOT_JNI_CALLBOOLEANMETHOD_RETURN(_ret_ref))
    DEFINE_NAEBALOVOCALLMETHOD(jbyte, Byte, T_BYTE
        , HOTSPOT_JNI_CALLBYTEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
        HOTSPOT_JNI_CALLBYTEMETHOD_RETURN(_ret_ref))
    DEFINE_NAEBALOVOCALLMETHOD(jchar, Char, T_CHAR
        , HOTSPOT_JNI_CALLCHARMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
        HOTSPOT_JNI_CALLCHARMETHOD_RETURN(_ret_ref))
    DEFINE_NAEBALOVOCALLMETHOD(jshort, Short, T_SHORT
        , HOTSPOT_JNI_CALLSHORTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
        HOTSPOT_JNI_CALLSHORTMETHOD_RETURN(_ret_ref))

    DEFINE_NAEBALOVOCALLMETHOD(jobject, Object, T_OBJECT
        , HOTSPOT_JNI_CALLOBJECTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
        HOTSPOT_JNI_CALLOBJECTMETHOD_RETURN(_ret_ref))
    DEFINE_NAEBALOVOCALLMETHOD(jint, Int, T_INT,
        HOTSPOT_JNI_CALLINTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
        HOTSPOT_JNI_CALLINTMETHOD_RETURN(_ret_ref))
    DEFINE_NAEBALOVOCALLMETHOD(jlong, Long, T_LONG
        , HOTSPOT_JNI_CALLLONGMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
        HOTSPOT_JNI_CALLLONGMETHOD_RETURN(_ret_ref))
    // Float and double probes don't return value because dtrace doesn't currently support it
    DEFINE_NAEBALOVOCALLMETHOD(jfloat, Float, T_FLOAT
        , HOTSPOT_JNI_CALLFLOATMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
        HOTSPOT_JNI_CALLFLOATMETHOD_RETURN())
    DEFINE_NAEBALOVOCALLMETHOD(jdouble, Double, T_DOUBLE
        , HOTSPOT_JNI_CALLDOUBLEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
        HOTSPOT_JNI_CALLDOUBLEMETHOD_RETURN())

#define DEFINE_CALLMETHOD(ResultType, Result, Tag \
                          , EntryProbe, ReturnProbe)    \
\
  DT_RETURN_MARK_DECL_FOR(Result, Call##Result##Method, ResultType \
                          , ReturnProbe);                          \
\
JNI_ENTRY(ResultType, \
          jni_Call##Result##Method(JNIEnv *env, jobject obj, jmethodID methodID, ...)) \
\
  EntryProbe; \
  ResultType ret = 0;\
  DT_RETURN_MARK_FOR(Result, Call##Result##Method, ResultType, \
                     (const ResultType&)ret);\
\
  va_list args; \
  va_start(args, methodID); \
  JavaValue jvalue(Tag); \
  JNI_ArgumentPusherVaArg ap(methodID, args); \
  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_0); \
  va_end(args); \
  ret = jvalue.get_##ResultType(); \
  return ret;\
JNI_END

// the runtime type of subword integral basic types is integer
DEFINE_CALLMETHOD(jboolean, Boolean, T_BOOLEAN
                  , HOTSPOT_JNI_CALLBOOLEANMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLBOOLEANMETHOD_RETURN(_ret_ref))
DEFINE_CALLMETHOD(jbyte,    Byte,    T_BYTE
                  , HOTSPOT_JNI_CALLBYTEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLBYTEMETHOD_RETURN(_ret_ref))
DEFINE_CALLMETHOD(jchar,    Char,    T_CHAR
                  , HOTSPOT_JNI_CALLCHARMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLCHARMETHOD_RETURN(_ret_ref))
DEFINE_CALLMETHOD(jshort,   Short,   T_SHORT
                  , HOTSPOT_JNI_CALLSHORTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLSHORTMETHOD_RETURN(_ret_ref))

DEFINE_CALLMETHOD(jobject,  Object,  T_OBJECT
                  , HOTSPOT_JNI_CALLOBJECTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLOBJECTMETHOD_RETURN(_ret_ref))
DEFINE_CALLMETHOD(jint,     Int,     T_INT,
                  HOTSPOT_JNI_CALLINTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLINTMETHOD_RETURN(_ret_ref))
DEFINE_CALLMETHOD(jlong,    Long,    T_LONG
                  , HOTSPOT_JNI_CALLLONGMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLLONGMETHOD_RETURN(_ret_ref))
// Float and double probes don't return value because dtrace doesn't currently support it
DEFINE_CALLMETHOD(jfloat,   Float,   T_FLOAT
                  , HOTSPOT_JNI_CALLFLOATMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLFLOATMETHOD_RETURN())
DEFINE_CALLMETHOD(jdouble,  Double,  T_DOUBLE
                  , HOTSPOT_JNI_CALLDOUBLEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLDOUBLEMETHOD_RETURN())

#define DEFINE_CALLMETHODV(ResultType, Result, Tag \
                          , EntryProbe, ReturnProbe)    \
\
  DT_RETURN_MARK_DECL_FOR(Result, Call##Result##MethodV, ResultType \
                          , ReturnProbe);                          \
\
JNI_ENTRY(ResultType, \
          jni_Call##Result##MethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args)) \
\
  EntryProbe;\
  ResultType ret = 0;\
  DT_RETURN_MARK_FOR(Result, Call##Result##MethodV, ResultType, \
                     (const ResultType&)ret);\
\
  JavaValue jvalue(Tag); \
  JNI_ArgumentPusherVaArg ap(methodID, args); \
  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_0); \
  ret = jvalue.get_##ResultType(); \
  return ret;\
JNI_END

// the runtime type of subword integral basic types is integer
DEFINE_CALLMETHODV(jboolean, Boolean, T_BOOLEAN
                  , HOTSPOT_JNI_CALLBOOLEANMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLBOOLEANMETHODV_RETURN(_ret_ref))
DEFINE_CALLMETHODV(jbyte,    Byte,    T_BYTE
                  , HOTSPOT_JNI_CALLBYTEMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLBYTEMETHODV_RETURN(_ret_ref))
DEFINE_CALLMETHODV(jchar,    Char,    T_CHAR
                  , HOTSPOT_JNI_CALLCHARMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLCHARMETHODV_RETURN(_ret_ref))
DEFINE_CALLMETHODV(jshort,   Short,   T_SHORT
                  , HOTSPOT_JNI_CALLSHORTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLSHORTMETHODV_RETURN(_ret_ref))

DEFINE_CALLMETHODV(jobject,  Object,  T_OBJECT
                  , HOTSPOT_JNI_CALLOBJECTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLOBJECTMETHODV_RETURN(_ret_ref))
DEFINE_CALLMETHODV(jint,     Int,     T_INT,
                  HOTSPOT_JNI_CALLINTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLINTMETHODV_RETURN(_ret_ref))
DEFINE_CALLMETHODV(jlong,    Long,    T_LONG
                  , HOTSPOT_JNI_CALLLONGMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLLONGMETHODV_RETURN(_ret_ref))
// Float and double probes don't return value because dtrace doesn't currently support it
DEFINE_CALLMETHODV(jfloat,   Float,   T_FLOAT
                  , HOTSPOT_JNI_CALLFLOATMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLFLOATMETHODV_RETURN())
DEFINE_CALLMETHODV(jdouble,  Double,  T_DOUBLE
                  , HOTSPOT_JNI_CALLDOUBLEMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLDOUBLEMETHODV_RETURN())

#define DEFINE_CALLMETHODA(ResultType, Result, Tag \
                          , EntryProbe, ReturnProbe)    \
\
  DT_RETURN_MARK_DECL_FOR(Result, Call##Result##MethodA, ResultType \
                          , ReturnProbe);                          \
\
JNI_ENTRY(ResultType, \
          jni_Call##Result##MethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args)) \
  EntryProbe; \
  ResultType ret = 0;\
  DT_RETURN_MARK_FOR(Result, Call##Result##MethodA, ResultType, \
                     (const ResultType&)ret);\
\
  JavaValue jvalue(Tag); \
  JNI_ArgumentPusherArray ap(methodID, args); \
  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_0); \
  ret = jvalue.get_##ResultType(); \
  return ret;\
JNI_END

// the runtime type of subword integral basic types is integer
DEFINE_CALLMETHODA(jboolean, Boolean, T_BOOLEAN
                  , HOTSPOT_JNI_CALLBOOLEANMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLBOOLEANMETHODA_RETURN(_ret_ref))
DEFINE_CALLMETHODA(jbyte,    Byte,    T_BYTE
                  , HOTSPOT_JNI_CALLBYTEMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLBYTEMETHODA_RETURN(_ret_ref))
DEFINE_CALLMETHODA(jchar,    Char,    T_CHAR
                  , HOTSPOT_JNI_CALLCHARMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLCHARMETHODA_RETURN(_ret_ref))
DEFINE_CALLMETHODA(jshort,   Short,   T_SHORT
                  , HOTSPOT_JNI_CALLSHORTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLSHORTMETHODA_RETURN(_ret_ref))

DEFINE_CALLMETHODA(jobject,  Object,  T_OBJECT
                  , HOTSPOT_JNI_CALLOBJECTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLOBJECTMETHODA_RETURN(_ret_ref))
DEFINE_CALLMETHODA(jint,     Int,     T_INT,
                  HOTSPOT_JNI_CALLINTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLINTMETHODA_RETURN(_ret_ref))
DEFINE_CALLMETHODA(jlong,    Long,    T_LONG
                  , HOTSPOT_JNI_CALLLONGMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLLONGMETHODA_RETURN(_ret_ref))
// Float and double probes don't return value because dtrace doesn't currently support it
DEFINE_CALLMETHODA(jfloat,   Float,   T_FLOAT
                  , HOTSPOT_JNI_CALLFLOATMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLFLOATMETHODA_RETURN())
DEFINE_CALLMETHODA(jdouble,  Double,  T_DOUBLE
                  , HOTSPOT_JNI_CALLDOUBLEMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
                  HOTSPOT_JNI_CALLDOUBLEMETHODA_RETURN())

DT_VOID_RETURN_MARK_DECL(CallVoidMethod, HOTSPOT_JNI_CALLVOIDMETHOD_RETURN());
DT_VOID_RETURN_MARK_DECL(CallVoidMethodV, HOTSPOT_JNI_CALLVOIDMETHODV_RETURN());
DT_VOID_RETURN_MARK_DECL(CallVoidMethodA, HOTSPOT_JNI_CALLVOIDMETHODA_RETURN());


JNI_ENTRY(void, jni_CallVoidMethod(JNIEnv *env, jobject obj, jmethodID methodID, ...))
  HOTSPOT_JNI_CALLVOIDMETHOD_ENTRY(env, obj, (uintptr_t) methodID);
  DT_VOID_RETURN_MARK(CallVoidMethod);

  va_list args;
  va_start(args, methodID);
  JavaValue jvalue(T_VOID);
  JNI_ArgumentPusherVaArg ap(methodID, args);
  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK);
  va_end(args);
JNI_END


JNI_ENTRY(void, jni_CallVoidMethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args))
  HOTSPOT_JNI_CALLVOIDMETHODV_ENTRY(env, obj, (uintptr_t) methodID);
  DT_VOID_RETURN_MARK(CallVoidMethodV);

  JavaValue jvalue(T_VOID);
  JNI_ArgumentPusherVaArg ap(methodID, args);
  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK);
JNI_END


JNI_ENTRY(void, jni_CallVoidMethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args))
  HOTSPOT_JNI_CALLVOIDMETHODA_ENTRY(env, obj, (uintptr_t) methodID);
  DT_VOID_RETURN_MARK(CallVoidMethodA);

  JavaValue jvalue(T_VOID);
  JNI_ArgumentPusherArray ap(methodID, args);
  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK);
JNI_END


#define DEFINE_NAEBALOVOCALLNONVIRTUALMETHOD(ResultType, Result, Tag \
                                    , EntryProbe, ReturnProbe)      \
\
  DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##Method, ResultType \
                          , ReturnProbe);\
\
JNI_ENTRY(ResultType, \
          jni_NaebalovoCallNonvirtual##Result##Method(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...)) \
\
  EntryProbe;\
  ResultType ret;\
  DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##Method, ResultType, \
                     (const ResultType&)ret);\
\
  va_list args; \
  va_start(args, methodID); \
  JavaValue jvalue(Tag); \
  JNI_ArgumentPusherVaArg ap(methodID, args); \
  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_0); \
  va_end(args); \
  ret = jvalue.get_##ResultType(); \
  return ret;\
JNI_END






DEFINE_NAEBALOVOCALLNONVIRTUALMETHOD(jboolean, Boolean, T_BOOLEAN
    , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
    HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_RETURN(_ret_ref))
    DEFINE_NAEBALOVOCALLNONVIRTUALMETHOD(jbyte, Byte, T_BYTE
        , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
        HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_RETURN(_ret_ref))
    DEFINE_NAEBALOVOCALLNONVIRTUALMETHOD(jchar, Char, T_CHAR
        , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
        HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_RETURN(_ret_ref))
    DEFINE_NAEBALOVOCALLNONVIRTUALMETHOD(jshort, Short, T_SHORT
        , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
        HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_RETURN(_ret_ref))

    DEFINE_NAEBALOVOCALLNONVIRTUALMETHOD(jobject, Object, T_OBJECT
        , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
        HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_RETURN(_ret_ref))
    DEFINE_NAEBALOVOCALLNONVIRTUALMETHOD(jint, Int, T_INT
        , HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
        HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_RETURN(_ret_ref))
    DEFINE_NAEBALOVOCALLNONVIRTUALMETHOD(jlong, Long, T_LONG
        , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
        // Float and double probes don't return value because dtrace doesn't currently support it
        HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_RETURN(_ret_ref))
    DEFINE_NAEBALOVOCALLNONVIRTUALMETHOD(jfloat, Float, T_FLOAT
        , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
        HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_RETURN())
    DEFINE_NAEBALOVOCALLNONVIRTUALMETHOD(jdouble, Double, T_DOUBLE
        , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
        HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_RETURN())



#define DEFINE_CALLNONVIRTUALMETHOD(ResultType, Result, Tag \
                                    , EntryProbe, ReturnProbe)      \
\
  DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##Method, ResultType \
                          , ReturnProbe);\
\
JNI_ENTRY(ResultType, \
          jni_CallNonvirtual##Result##Method(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...)) \
\
  EntryProbe;\
  ResultType ret;\
  DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##Method, ResultType, \
                     (const ResultType&)ret);\
\
  va_list args; \
  va_start(args, methodID); \
  JavaValue jvalue(Tag); \
  JNI_ArgumentPusherVaArg ap(methodID, args); \
  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_0); \
  va_end(args); \
  ret = jvalue.get_##ResultType(); \
  return ret;\
JNI_END

// the runtime type of subword integral basic types is integer
DEFINE_CALLNONVIRTUALMETHOD(jboolean, Boolean, T_BOOLEAN
                            , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
                            HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_RETURN(_ret_ref))
DEFINE_CALLNONVIRTUALMETHOD(jbyte,    Byte,    T_BYTE
                            , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
                            HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_RETURN(_ret_ref))
DEFINE_CALLNONVIRTUALMETHOD(jchar,    Char,    T_CHAR
                            , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
                            HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_RETURN(_ret_ref))
DEFINE_CALLNONVIRTUALMETHOD(jshort,   Short,   T_SHORT
                            , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
                            HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_RETURN(_ret_ref))

DEFINE_CALLNONVIRTUALMETHOD(jobject,  Object,  T_OBJECT
                            , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
                            HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_RETURN(_ret_ref))
DEFINE_CALLNONVIRTUALMETHOD(jint,     Int,     T_INT
                            , HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
                            HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_RETURN(_ret_ref))
DEFINE_CALLNONVIRTUALMETHOD(jlong,    Long,    T_LONG
                            , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
// Float and double probes don't return value because dtrace doesn't currently support it
                            HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_RETURN(_ret_ref))
DEFINE_CALLNONVIRTUALMETHOD(jfloat,   Float,   T_FLOAT
                            , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
                            HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_RETURN())
DEFINE_CALLNONVIRTUALMETHOD(jdouble,  Double,  T_DOUBLE
                            , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
                            HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_RETURN())

#define DEFINE_CALLNONVIRTUALMETHODV(ResultType, Result, Tag \
                                    , EntryProbe, ReturnProbe)      \
\
  DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##MethodV, ResultType \
                          , ReturnProbe);\
\
JNI_ENTRY(ResultType, \
          jni_CallNonvirtual##Result##MethodV(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args)) \
\
  EntryProbe;\
  ResultType ret;\
  DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##MethodV, ResultType, \
                     (const ResultType&)ret);\
\
  JavaValue jvalue(Tag); \
  JNI_ArgumentPusherVaArg ap(methodID, args); \
  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_0); \
  ret = jvalue.get_##ResultType(); \
  return ret;\
JNI_END

// the runtime type of subword integral basic types is integer
DEFINE_CALLNONVIRTUALMETHODV(jboolean, Boolean, T_BOOLEAN
                            , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
                            HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_RETURN(_ret_ref))
DEFINE_CALLNONVIRTUALMETHODV(jbyte,    Byte,    T_BYTE
                            , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
                            HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_RETURN(_ret_ref))
DEFINE_CALLNONVIRTUALMETHODV(jchar,    Char,    T_CHAR
                            , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
                            HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_RETURN(_ret_ref))
DEFINE_CALLNONVIRTUALMETHODV(jshort,   Short,   T_SHORT
                            , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
                            HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_RETURN(_ret_ref))

DEFINE_CALLNONVIRTUALMETHODV(jobject,  Object,  T_OBJECT
                            , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
                            HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_RETURN(_ret_ref))
DEFINE_CALLNONVIRTUALMETHODV(jint,     Int,     T_INT
                            , HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
                            HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_RETURN(_ret_ref))
DEFINE_CALLNONVIRTUALMETHODV(jlong,    Long,    T_LONG
                            , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
// Float and double probes don't return value because dtrace doesn't currently support it
                            HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_RETURN(_ret_ref))
DEFINE_CALLNONVIRTUALMETHODV(jfloat,   Float,   T_FLOAT
                            , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
                            HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_RETURN())
DEFINE_CALLNONVIRTUALMETHODV(jdouble,  Double,  T_DOUBLE
                            , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
                            HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_RETURN())

#define DEFINE_CALLNONVIRTUALMETHODA(ResultType, Result, Tag \
                                    , EntryProbe, ReturnProbe)      \
\
  DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##MethodA, ResultType \
                          , ReturnProbe);\
\
JNI_ENTRY(ResultType, \
          jni_CallNonvirtual##Result##MethodA(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args)) \
\
  EntryProbe;\
  ResultType ret;\
  DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##MethodA, ResultType, \
                     (const ResultType&)ret);\
\
  JavaValue jvalue(Tag); \
  JNI_ArgumentPusherArray ap(methodID, args); \
  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_0); \
  ret = jvalue.get_##ResultType(); \
  return ret;\
JNI_END

// the runtime type of subword integral basic types is integer
DEFINE_CALLNONVIRTUALMETHODA(jboolean, Boolean, T_BOOLEAN
                            , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
                            HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_RETURN(_ret_ref))
DEFINE_CALLNONVIRTUALMETHODA(jbyte,    Byte,    T_BYTE
                            , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
                            HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_RETURN(_ret_ref))
DEFINE_CALLNONVIRTUALMETHODA(jchar,    Char,    T_CHAR
                            , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
                            HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_RETURN(_ret_ref))
DEFINE_CALLNONVIRTUALMETHODA(jshort,   Short,   T_SHORT
                            , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
                            HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_RETURN(_ret_ref))

DEFINE_CALLNONVIRTUALMETHODA(jobject,  Object,  T_OBJECT
                            , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
                            HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_RETURN(_ret_ref))
DEFINE_CALLNONVIRTUALMETHODA(jint,     Int,     T_INT
                            , HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
                            HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_RETURN(_ret_ref))
DEFINE_CALLNONVIRTUALMETHODA(jlong,    Long,    T_LONG
                            , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
// Float and double probes don't return value because dtrace doesn't currently support it
                            HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_RETURN(_ret_ref))
DEFINE_CALLNONVIRTUALMETHODA(jfloat,   Float,   T_FLOAT
                            , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
                            HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_RETURN())
DEFINE_CALLNONVIRTUALMETHODA(jdouble,  Double,  T_DOUBLE
                            , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
                            HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_RETURN())

DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethod
                         , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_RETURN());
DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethodV
                         , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_RETURN());
DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethodA
                         , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_RETURN());

JNI_ENTRY(void, jni_CallNonvirtualVoidMethod(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...))
  HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_ENTRY(env, obj, cls, (uintptr_t) methodID);
  DT_VOID_RETURN_MARK(CallNonvirtualVoidMethod);

  va_list args;
  va_start(args, methodID);
  JavaValue jvalue(T_VOID);
  JNI_ArgumentPusherVaArg ap(methodID, args);
  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK);
  va_end(args);
JNI_END


JNI_ENTRY(void, jni_CallNonvirtualVoidMethodV(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args))
  HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_ENTRY(
               env, obj, cls, (uintptr_t) methodID);
  DT_VOID_RETURN_MARK(CallNonvirtualVoidMethodV);

  JavaValue jvalue(T_VOID);
  JNI_ArgumentPusherVaArg ap(methodID, args);
  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK);
JNI_END


JNI_ENTRY(void, jni_CallNonvirtualVoidMethodA(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args))
  HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_ENTRY(
                env, obj, cls, (uintptr_t) methodID);
  DT_VOID_RETURN_MARK(CallNonvirtualVoidMethodA);
  JavaValue jvalue(T_VOID);
  JNI_ArgumentPusherArray ap(methodID, args);
  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK);
JNI_END


jobject jni_NodeCallStaticObjectMethod(JNIEnv* env, jmethodID methodID, ...) {
    JavaThread* __the_thread__ = JavaThread::thread_from_jni_environment(env);
    va_list args;
    va_start(args, methodID);
    JavaValue jvalue(T_OBJECT);
    JNI_ArgumentPusherVaArg ap(methodID, args);
    jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_0);
    va_end(args);
    Handle ref_handle(__the_thread__, JNIHandles::resolve((jobject)jvalue.get_jobject()));
    return JNIHandles::make_global(ref_handle, AllocFailStrategy::RETURN_NULL);
}
//(jobject,  Object,  T_OBJECT

JNI_ENTRY(jobject, 
    jni_NaebalovoCallStaticObjectMethod(JNIEnv* env, jmethodID methodID, ...))
        jobject ret = 0; 
    
    va_list args; \
    va_start(args, methodID); 
    JavaValue jvalue(T_OBJECT);
    JNI_ArgumentPusherVaArg ap(methodID, args); 
    jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_0); 
    va_end(args); 
    ret = (jobject)jvalue.get_jobject();
    return ret; 
JNI_END

#define DEFINE_CALLSTATICMETHOD(ResultType, Result, Tag \
                                , EntryProbe, ResultProbe) \
\
  DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##Method, ResultType \
                          , ResultProbe);                               \
\
JNI_ENTRY(ResultType, \
          jni_CallStatic##Result##Method(JNIEnv *env, jclass cls, jmethodID methodID, ...)) \
\
  EntryProbe; \
  ResultType ret = 0;\
  DT_RETURN_MARK_FOR(Result, CallStatic##Result##Method, ResultType, \
                     (const ResultType&)ret);\
\
  va_list args; \
  va_start(args, methodID); \
  JavaValue jvalue(Tag); \
  JNI_ArgumentPusherVaArg ap(methodID, args); \
  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_0); \
  va_end(args); \
  ret = jvalue.get_##ResultType(); \
  return ret;\
JNI_END

// the runtime type of subword integral basic types is integer
DEFINE_CALLSTATICMETHOD(jboolean, Boolean, T_BOOLEAN
                        , HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_RETURN(_ret_ref));
DEFINE_CALLSTATICMETHOD(jbyte,    Byte,    T_BYTE
                        , HOTSPOT_JNI_CALLSTATICBYTEMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICBYTEMETHOD_RETURN(_ret_ref));
DEFINE_CALLSTATICMETHOD(jchar,    Char,    T_CHAR
                        , HOTSPOT_JNI_CALLSTATICCHARMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICCHARMETHOD_RETURN(_ret_ref));
DEFINE_CALLSTATICMETHOD(jshort,   Short,   T_SHORT
                        , HOTSPOT_JNI_CALLSTATICSHORTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICSHORTMETHOD_RETURN(_ret_ref));

DEFINE_CALLSTATICMETHOD(jobject,  Object,  T_OBJECT
                        , HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_RETURN(_ret_ref));
DEFINE_CALLSTATICMETHOD(jint,     Int,     T_INT
                        , HOTSPOT_JNI_CALLSTATICINTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICINTMETHOD_RETURN(_ret_ref));
DEFINE_CALLSTATICMETHOD(jlong,    Long,    T_LONG
                        , HOTSPOT_JNI_CALLSTATICLONGMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICLONGMETHOD_RETURN(_ret_ref));
// Float and double probes don't return value because dtrace doesn't currently support it
DEFINE_CALLSTATICMETHOD(jfloat,   Float,   T_FLOAT
                        , HOTSPOT_JNI_CALLSTATICFLOATMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICFLOATMETHOD_RETURN());
DEFINE_CALLSTATICMETHOD(jdouble,  Double,  T_DOUBLE
                        , HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_RETURN());





#define DEFINE_NAEBALOVOCALLSTATICMETHOD(ResultType, Result, Tag \
                                , EntryProbe, ResultProbe) \
\
  DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##Method, ResultType \
                          , ResultProbe);                               \
\
JNI_ENTRY(ResultType, \
          jni_NaebalovoCallStatic##Result##Method(JNIEnv *env, jmethodID methodID, ...)) \
\
  EntryProbe; \
  ResultType ret = 0;\
  DT_RETURN_MARK_FOR(Result, CallStatic##Result##Method, ResultType, \
                     (const ResultType&)ret);\
\
  va_list args; \
  va_start(args, methodID); \
  JavaValue jvalue(Tag); \
  JNI_ArgumentPusherVaArg ap(methodID, args); \
  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_0); \
  va_end(args); \
  ret = jvalue.get_##ResultType(); \
  return ret;\
JNI_END

// the runtime type of subword integral basic types is integer
DEFINE_NAEBALOVOCALLSTATICMETHOD(jboolean, Boolean, T_BOOLEAN
    , HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
    HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_RETURN(_ret_ref));
DEFINE_NAEBALOVOCALLSTATICMETHOD(jbyte, Byte, T_BYTE
    , HOTSPOT_JNI_CALLSTATICBYTEMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
    HOTSPOT_JNI_CALLSTATICBYTEMETHOD_RETURN(_ret_ref));
DEFINE_NAEBALOVOCALLSTATICMETHOD(jchar, Char, T_CHAR
    , HOTSPOT_JNI_CALLSTATICCHARMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
    HOTSPOT_JNI_CALLSTATICCHARMETHOD_RETURN(_ret_ref));
DEFINE_NAEBALOVOCALLSTATICMETHOD(jshort, Short, T_SHORT
    , HOTSPOT_JNI_CALLSTATICSHORTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
    HOTSPOT_JNI_CALLSTATICSHORTMETHOD_RETURN(_ret_ref));

//DEFINE_NAEBALOVOCALLSTATICMETHOD(jobject, Object, T_OBJECT
//    , HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
//    HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_RETURN(_ret_ref));
DEFINE_NAEBALOVOCALLSTATICMETHOD(jint, Int, T_INT
    , HOTSPOT_JNI_CALLSTATICINTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
    HOTSPOT_JNI_CALLSTATICINTMETHOD_RETURN(_ret_ref));
DEFINE_NAEBALOVOCALLSTATICMETHOD(jlong, Long, T_LONG
    , HOTSPOT_JNI_CALLSTATICLONGMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
    HOTSPOT_JNI_CALLSTATICLONGMETHOD_RETURN(_ret_ref));
// Float and double probes don't return value because dtrace doesn't currently support it
DEFINE_NAEBALOVOCALLSTATICMETHOD(jfloat, Float, T_FLOAT
    , HOTSPOT_JNI_CALLSTATICFLOATMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
    HOTSPOT_JNI_CALLSTATICFLOATMETHOD_RETURN());
DEFINE_NAEBALOVOCALLSTATICMETHOD(jdouble, Double, T_DOUBLE
    , HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
    HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_RETURN());



#define DEFINE_CALLSTATICMETHODV(ResultType, Result, Tag \
                                , EntryProbe, ResultProbe) \
\
  DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##MethodV, ResultType \
                          , ResultProbe);                               \
\
JNI_ENTRY(ResultType, \
          jni_CallStatic##Result##MethodV(JNIEnv *env, jclass cls, jmethodID methodID, va_list args)) \
\
  EntryProbe; \
  ResultType ret = 0;\
  DT_RETURN_MARK_FOR(Result, CallStatic##Result##MethodV, ResultType, \
                     (const ResultType&)ret);\
\
  JavaValue jvalue(Tag); \
  JNI_ArgumentPusherVaArg ap(methodID, args); \
  /* Make sure class is initialized before trying to invoke its method */ \
  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls)); \
  k->initialize(CHECK_0); \
  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_0); \
  va_end(args); \
  ret = jvalue.get_##ResultType(); \
  return ret;\
JNI_END

// the runtime type of subword integral basic types is integer
DEFINE_CALLSTATICMETHODV(jboolean, Boolean, T_BOOLEAN
                        , HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_RETURN(_ret_ref));
DEFINE_CALLSTATICMETHODV(jbyte,    Byte,    T_BYTE
                        , HOTSPOT_JNI_CALLSTATICBYTEMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICBYTEMETHODV_RETURN(_ret_ref));
DEFINE_CALLSTATICMETHODV(jchar,    Char,    T_CHAR
                        , HOTSPOT_JNI_CALLSTATICCHARMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICCHARMETHODV_RETURN(_ret_ref));
DEFINE_CALLSTATICMETHODV(jshort,   Short,   T_SHORT
                        , HOTSPOT_JNI_CALLSTATICSHORTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICSHORTMETHODV_RETURN(_ret_ref));

DEFINE_CALLSTATICMETHODV(jobject,  Object,  T_OBJECT
                        , HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_RETURN(_ret_ref));
DEFINE_CALLSTATICMETHODV(jint,     Int,     T_INT
                        , HOTSPOT_JNI_CALLSTATICINTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICINTMETHODV_RETURN(_ret_ref));
DEFINE_CALLSTATICMETHODV(jlong,    Long,    T_LONG
                        , HOTSPOT_JNI_CALLSTATICLONGMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICLONGMETHODV_RETURN(_ret_ref));
// Float and double probes don't return value because dtrace doesn't currently support it
DEFINE_CALLSTATICMETHODV(jfloat,   Float,   T_FLOAT
                        , HOTSPOT_JNI_CALLSTATICFLOATMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICFLOATMETHODV_RETURN());
DEFINE_CALLSTATICMETHODV(jdouble,  Double,  T_DOUBLE
                        , HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_RETURN());

#define DEFINE_CALLSTATICMETHODA(ResultType, Result, Tag \
                                , EntryProbe, ResultProbe) \
\
  DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##MethodA, ResultType \
                          , ResultProbe);                               \
\
JNI_ENTRY(ResultType, \
          jni_CallStatic##Result##MethodA(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args)) \
\
  EntryProbe; \
  ResultType ret = 0;\
  DT_RETURN_MARK_FOR(Result, CallStatic##Result##MethodA, ResultType, \
                     (const ResultType&)ret);\
\
  JavaValue jvalue(Tag); \
  JNI_ArgumentPusherArray ap(methodID, args); \
  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_0); \
  ret = jvalue.get_##ResultType(); \
  return ret;\
JNI_END

// the runtime type of subword integral basic types is integer
DEFINE_CALLSTATICMETHODA(jboolean, Boolean, T_BOOLEAN
                        , HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_RETURN(_ret_ref));
DEFINE_CALLSTATICMETHODA(jbyte,    Byte,    T_BYTE
                        , HOTSPOT_JNI_CALLSTATICBYTEMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICBYTEMETHODA_RETURN(_ret_ref));
DEFINE_CALLSTATICMETHODA(jchar,    Char,    T_CHAR
                        , HOTSPOT_JNI_CALLSTATICCHARMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICCHARMETHODA_RETURN(_ret_ref));
DEFINE_CALLSTATICMETHODA(jshort,   Short,   T_SHORT
                        , HOTSPOT_JNI_CALLSTATICSHORTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICSHORTMETHODA_RETURN(_ret_ref));

DEFINE_CALLSTATICMETHODA(jobject,  Object,  T_OBJECT
                        , HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_RETURN(_ret_ref));
DEFINE_CALLSTATICMETHODA(jint,     Int,     T_INT
                        , HOTSPOT_JNI_CALLSTATICINTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICINTMETHODA_RETURN(_ret_ref));
DEFINE_CALLSTATICMETHODA(jlong,    Long,    T_LONG
                        , HOTSPOT_JNI_CALLSTATICLONGMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICLONGMETHODA_RETURN(_ret_ref));
// Float and double probes don't return value because dtrace doesn't currently support it
DEFINE_CALLSTATICMETHODA(jfloat,   Float,   T_FLOAT
                        , HOTSPOT_JNI_CALLSTATICFLOATMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICFLOATMETHODA_RETURN());
DEFINE_CALLSTATICMETHODA(jdouble,  Double,  T_DOUBLE
                        , HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
                        HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_RETURN());

DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethod
                         , HOTSPOT_JNI_CALLSTATICVOIDMETHOD_RETURN());
DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethodV
                         , HOTSPOT_JNI_CALLSTATICVOIDMETHODV_RETURN());
DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethodA
                         , HOTSPOT_JNI_CALLSTATICVOIDMETHODA_RETURN());

JNI_ENTRY(void, jni_CallStaticVoidMethod(JNIEnv *env, jclass cls, jmethodID methodID, ...))
  HOTSPOT_JNI_CALLSTATICVOIDMETHOD_ENTRY(env, cls, (uintptr_t) methodID);
  DT_VOID_RETURN_MARK(CallStaticVoidMethod);

  va_list args;
  va_start(args, methodID);
  JavaValue jvalue(T_VOID);
  JNI_ArgumentPusherVaArg ap(methodID, args);
  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK);
  va_end(args);
JNI_END

JNI_ENTRY(void, jni_NaebalovoCallStaticVoidMethod(JNIEnv * env, jmethodID methodID, ...))
HOTSPOT_JNI_CALLSTATICVOIDMETHOD_ENTRY(env, cls, (uintptr_t)methodID);
DT_VOID_RETURN_MARK(CallStaticVoidMethod);

va_list args;
va_start(args, methodID);
JavaValue jvalue(T_VOID);
JNI_ArgumentPusherVaArg ap(methodID, args);
jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK);
va_end(args);
JNI_END


JNI_ENTRY(void, jni_CallStaticVoidMethodV(JNIEnv *env, jclass cls, jmethodID methodID, va_list args))
  HOTSPOT_JNI_CALLSTATICVOIDMETHODV_ENTRY(env, cls, (uintptr_t) methodID);
  DT_VOID_RETURN_MARK(CallStaticVoidMethodV);

  JavaValue jvalue(T_VOID);
  JNI_ArgumentPusherVaArg ap(methodID, args);
  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK);
JNI_END


JNI_ENTRY(void, jni_CallStaticVoidMethodA(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args))
  HOTSPOT_JNI_CALLSTATICVOIDMETHODA_ENTRY(env, cls, (uintptr_t) methodID);
  DT_VOID_RETURN_MARK(CallStaticVoidMethodA);

  JavaValue jvalue(T_VOID);
  JNI_ArgumentPusherArray ap(methodID, args);
  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK);
JNI_END


//
// Accessing Fields
//


DT_RETURN_MARK_DECL(GetFieldID, jfieldID
                    , HOTSPOT_JNI_GETFIELDID_RETURN((uintptr_t)_ret_ref));

JNI_ENTRY(jfieldID, jni_GetFieldID(JNIEnv *env, jclass clazz,
          const char *name, const char *sig))
  HOTSPOT_JNI_GETFIELDID_ENTRY(env, clazz, (char *) name, (char *) sig);
  jfieldID ret = 0;
  DT_RETURN_MARK(GetFieldID, jfieldID, (const jfieldID&)ret);

  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));

  // The class should have been loaded (we have an instance of the class
  // passed in) so the field and signature should already be in the symbol
  // table.  If they're not there, the field doesn't exist.
  TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
  TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
  if (fieldname == nullptr || signame == nullptr) {
    ResourceMark rm;
    THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg("%s.%s %s", k->external_name(), name, sig));
  }

  // Make sure class is initialized before handing id's out to fields
  k->initialize(CHECK_NULL);

  fieldDescriptor fd;
  if (!k->is_instance_klass() ||
      !InstanceKlass::cast(k)->find_field(fieldname, signame, false, &fd)) {
    ResourceMark rm;
    THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg("%s.%s %s", k->external_name(), name, sig));
  }

  // A jfieldID for a non-static field is simply the offset of the field within the instanceOop
  // It may also have hash bits for k, if VerifyJNIFields is turned on.
  ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset());
  return ret;
JNI_END


JNI_ENTRY(jobject, jni_GetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID))
  HOTSPOT_JNI_GETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID);
  oop o = JNIHandles::resolve_non_null(obj);
  Klass* k = o->klass();
  int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
  // Keep JVMTI addition small and only check enabled flag here.
  // jni_GetField_probe() assumes that is okay to create handles.
  if (JvmtiExport::should_post_field_access()) {
    o = JvmtiExport::jni_GetField_probe(thread, obj, o, k, fieldID, false);
  }
  oop loaded_obj = HeapAccess<ON_UNKNOWN_OOP_REF>::oop_load_at(o, offset);
  jobject ret = JNIHandles::make_local(THREAD, loaded_obj);
  HOTSPOT_JNI_GETOBJECTFIELD_RETURN(ret);
  return ret;
JNI_END



#define DEFINE_GETFIELD(Return,Fieldname,Result \
  , EntryProbe, ReturnProbe) \
\
  DT_RETURN_MARK_DECL_FOR(Result, Get##Result##Field, Return \
  , ReturnProbe); \
\
JNI_ENTRY_NO_PRESERVE(Return, jni_Get##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID)) \
\
  EntryProbe; \
  Return ret = 0;\
  DT_RETURN_MARK_FOR(Result, Get##Result##Field, Return, (const Return&)ret);\
\
  oop o = JNIHandles::resolve_non_null(obj); \
  Klass* k = o->klass(); \
  int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
  /* Keep JVMTI addition small and only check enabled flag here.       */ \
  if (JvmtiExport::should_post_field_access()) { \
    o = JvmtiExport::jni_GetField_probe(thread, obj, o, k, fieldID, false); \
  } \
  ret = o->Fieldname##_field(offset); \
  return ret; \
JNI_END

DEFINE_GETFIELD(jboolean, bool,   Boolean
                , HOTSPOT_JNI_GETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
                HOTSPOT_JNI_GETBOOLEANFIELD_RETURN(_ret_ref))
DEFINE_GETFIELD(jbyte,    byte,   Byte
                , HOTSPOT_JNI_GETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
                HOTSPOT_JNI_GETBYTEFIELD_RETURN(_ret_ref))
DEFINE_GETFIELD(jchar,    char,   Char
                , HOTSPOT_JNI_GETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
                HOTSPOT_JNI_GETCHARFIELD_RETURN(_ret_ref))
DEFINE_GETFIELD(jshort,   short,  Short
                , HOTSPOT_JNI_GETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
                HOTSPOT_JNI_GETSHORTFIELD_RETURN(_ret_ref))
DEFINE_GETFIELD(jint,     int,    Int
                , HOTSPOT_JNI_GETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
                HOTSPOT_JNI_GETINTFIELD_RETURN(_ret_ref))
DEFINE_GETFIELD(jlong,    long,   Long
                , HOTSPOT_JNI_GETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
                HOTSPOT_JNI_GETLONGFIELD_RETURN(_ret_ref))
// Float and double probes don't return value because dtrace doesn't currently support it
DEFINE_GETFIELD(jfloat,   float,  Float
                , HOTSPOT_JNI_GETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
                HOTSPOT_JNI_GETFLOATFIELD_RETURN())
DEFINE_GETFIELD(jdouble,  double, Double
                , HOTSPOT_JNI_GETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
                HOTSPOT_JNI_GETDOUBLEFIELD_RETURN())

address jni_GetBooleanField_addr() {
  return (address)jni_GetBooleanField;
}
address jni_GetByteField_addr() {
  return (address)jni_GetByteField;
}
address jni_GetCharField_addr() {
  return (address)jni_GetCharField;
}
address jni_GetShortField_addr() {
  return (address)jni_GetShortField;
}
address jni_GetIntField_addr() {
  return (address)jni_GetIntField;
}
address jni_GetLongField_addr() {
  return (address)jni_GetLongField;
}
address jni_GetFloatField_addr() {
  return (address)jni_GetFloatField;
}
address jni_GetDoubleField_addr() {
  return (address)jni_GetDoubleField;
}

JNI_ENTRY_NO_PRESERVE(void, jni_SetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID, jobject value))
  HOTSPOT_JNI_SETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID, value);
  oop o = JNIHandles::resolve_non_null(obj);
  Klass* k = o->klass();
  int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
  // Keep JVMTI addition small and only check enabled flag here.
  if (JvmtiExport::should_post_field_modification()) {
    jvalue field_value;
    field_value.l = value;
    o = JvmtiExport::jni_SetField_probe(thread, obj, o, k, fieldID, false, JVM_SIGNATURE_CLASS, (jvalue *)&field_value);
  }
  HeapAccess<ON_UNKNOWN_OOP_REF>::oop_store_at(o, offset, JNIHandles::resolve(value));
  HOTSPOT_JNI_SETOBJECTFIELD_RETURN();
JNI_END

// TODO: make this a template

#define DEFINE_SETFIELD(Argument,Fieldname,Result,SigType,unionType \
                        , EntryProbe, ReturnProbe) \
\
JNI_ENTRY_NO_PRESERVE(void, jni_Set##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID, Argument value)) \
\
  EntryProbe; \
\
  oop o = JNIHandles::resolve_non_null(obj); \
  Klass* k = o->klass(); \
  int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
  /* Keep JVMTI addition small and only check enabled flag here.       */ \
  if (JvmtiExport::should_post_field_modification()) { \
    jvalue field_value; \
    field_value.unionType = value; \
    o = JvmtiExport::jni_SetField_probe(thread, obj, o, k, fieldID, false, SigType, (jvalue *)&field_value); \
  } \
  o->Fieldname##_field_put(offset, value); \
  ReturnProbe; \
JNI_END

DEFINE_SETFIELD(jboolean, bool,   Boolean, JVM_SIGNATURE_BOOLEAN, z
                , HOTSPOT_JNI_SETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
                HOTSPOT_JNI_SETBOOLEANFIELD_RETURN())
DEFINE_SETFIELD(jbyte,    byte,   Byte,    JVM_SIGNATURE_BYTE, b
                , HOTSPOT_JNI_SETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
                HOTSPOT_JNI_SETBYTEFIELD_RETURN())
DEFINE_SETFIELD(jchar,    char,   Char,    JVM_SIGNATURE_CHAR, c
                , HOTSPOT_JNI_SETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
                HOTSPOT_JNI_SETCHARFIELD_RETURN())
DEFINE_SETFIELD(jshort,   short,  Short,   JVM_SIGNATURE_SHORT, s
                , HOTSPOT_JNI_SETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
                HOTSPOT_JNI_SETSHORTFIELD_RETURN())
DEFINE_SETFIELD(jint,     int,    Int,     JVM_SIGNATURE_INT, i
                , HOTSPOT_JNI_SETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
                HOTSPOT_JNI_SETINTFIELD_RETURN())
DEFINE_SETFIELD(jlong,    long,   Long,    JVM_SIGNATURE_LONG, j
                , HOTSPOT_JNI_SETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
                HOTSPOT_JNI_SETLONGFIELD_RETURN())
// Float and double probes don't return value because dtrace doesn't currently support it
DEFINE_SETFIELD(jfloat,   float,  Float,   JVM_SIGNATURE_FLOAT, f
                , HOTSPOT_JNI_SETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
                HOTSPOT_JNI_SETFLOATFIELD_RETURN())
DEFINE_SETFIELD(jdouble,  double, Double,  JVM_SIGNATURE_DOUBLE, d
                , HOTSPOT_JNI_SETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
                HOTSPOT_JNI_SETDOUBLEFIELD_RETURN())

DT_RETURN_MARK_DECL(ToReflectedField, jobject
                    , HOTSPOT_JNI_TOREFLECTEDFIELD_RETURN(_ret_ref));

JNI_ENTRY(jobject, jni_ToReflectedField(JNIEnv *env, jclass cls, jfieldID fieldID, jboolean isStatic))
  HOTSPOT_JNI_TOREFLECTEDFIELD_ENTRY(env, cls, (uintptr_t) fieldID, isStatic);
  jobject ret = nullptr;
  DT_RETURN_MARK(ToReflectedField, jobject, (const jobject&)ret);

  fieldDescriptor fd;
  bool found = false;
  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));

  assert(jfieldIDWorkaround::is_static_jfieldID(fieldID) == (isStatic != 0), "invalid fieldID");

  if (isStatic) {
    // Static field. The fieldID a JNIid specifying the field holder and the offset within the Klass*.
    JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
    assert(id->is_static_field_id(), "invalid static field id");
    found = id->find_local_field(&fd);
  } else {
    // Non-static field. The fieldID is really the offset of the field within the instanceOop.
    int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
    found = InstanceKlass::cast(k)->find_field_from_offset(offset, false, &fd);
  }
  assert(found, "bad fieldID passed into jni_ToReflectedField");
  oop reflected = Reflection::new_field(&fd, CHECK_NULL);
  ret = JNIHandles::make_local(THREAD, reflected);
  return ret;
JNI_END


//
// Accessing Static Fields
//
DT_RETURN_MARK_DECL(GetStaticFieldID, jfieldID
                    , HOTSPOT_JNI_GETSTATICFIELDID_RETURN((uintptr_t)_ret_ref));

JNI_ENTRY(jfieldID, jni_GetStaticFieldID(JNIEnv *env, jclass clazz,
          const char *name, const char *sig))
  HOTSPOT_JNI_GETSTATICFIELDID_ENTRY(env, clazz, (char *) name, (char *) sig);
  jfieldID ret = nullptr;
  DT_RETURN_MARK(GetStaticFieldID, jfieldID, (const jfieldID&)ret);

  // The class should have been loaded (we have an instance of the class
  // passed in) so the field and signature should already be in the symbol
  // table.  If they're not there, the field doesn't exist.
  TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
  TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
  if (fieldname == nullptr || signame == nullptr) {
    THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
  }
  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
  // Make sure class is initialized before handing id's out to static fields
  k->initialize(CHECK_NULL);

  fieldDescriptor fd;
  if (!k->is_instance_klass() ||
      !InstanceKlass::cast(k)->find_field(fieldname, signame, true, &fd)) {
    THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
  }

  // A jfieldID for a static field is a JNIid specifying the field holder and the offset within the Klass*
  JNIid* id = fd.field_holder()->jni_id_for(fd.offset());
  debug_only(id->set_is_static_field_id();)

  debug_only(id->verify(fd.field_holder()));

  ret = jfieldIDWorkaround::to_static_jfieldID(id);
  return ret;
JNI_END


JNI_ENTRY(jobject, jni_GetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID))
  HOTSPOT_JNI_GETSTATICOBJECTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID);
#if INCLUDE_JNI_CHECK
  DEBUG_ONLY(Klass* param_k = jniCheck::validate_class(thread, clazz);)
#endif // INCLUDE_JNI_CHECK
  JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
  assert(id->is_static_field_id(), "invalid static field id");
  // Keep JVMTI addition small and only check enabled flag here.
  // jni_GetField_probe() assumes that is okay to create handles.
  if (JvmtiExport::should_post_field_access()) {
    JvmtiExport::jni_GetField_probe(thread, nullptr, nullptr, id->holder(), fieldID, true);
  }
  jobject ret = JNIHandles::make_local(THREAD, id->holder()->java_mirror()->obj_field(id->offset()));
  HOTSPOT_JNI_GETSTATICOBJECTFIELD_RETURN(ret);
  return ret;
JNI_END

JNI_ENTRY(jobject, jni_NaebalovoGetStaticObjectField(JNIEnv * env, jfieldID fieldID))
HOTSPOT_JNI_GETSTATICOBJECTFIELD_ENTRY(env, clazz, (uintptr_t)fieldID);
#if INCLUDE_JNI_CHECK
DEBUG_ONLY(Klass * param_k = jniCheck::validate_class(thread, clazz);)
#endif // INCLUDE_JNI_CHECK
JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
assert(id->is_static_field_id(), "invalid static field id");
// Keep JVMTI addition small and only check enabled flag here.
// jni_GetField_probe() assumes that is okay to create handles.
if (JvmtiExport::should_post_field_access()) {
    JvmtiExport::jni_GetField_probe(thread, nullptr, nullptr, id->holder(), fieldID, true);
}
jobject ret = JNIHandles::make_local(THREAD, id->holder()->java_mirror()->obj_field(id->offset()));
HOTSPOT_JNI_GETSTATICOBJECTFIELD_RETURN(ret);
return ret;
JNI_END







#define DEFINE_NAEBALOVOGETSTATICFIELD(Return,Fieldname,Result \
                              , EntryProbe, ReturnProbe) \
\
  DT_RETURN_MARK_DECL_FOR(Result, GetStatic##Result##Field, Return \
                          , ReturnProbe);                                          \
\
JNI_ENTRY(Return, jni_NaebalovoGetStatic##Result##Field(JNIEnv *env, jfieldID fieldID)) \
  EntryProbe; \
  Return ret = 0;\
  DT_RETURN_MARK_FOR(Result, GetStatic##Result##Field, Return, \
                     (const Return&)ret);\
  JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
  assert(id->is_static_field_id(), "invalid static field id"); \
  /* Keep JVMTI addition small and only check enabled flag here. */ \
  /* jni_GetField_probe() assumes that is okay to create handles. */ \
  if (JvmtiExport::should_post_field_access()) { \
    JvmtiExport::jni_GetField_probe(thread, nullptr, nullptr, id->holder(), fieldID, true); \
  } \
  ret = id->holder()->java_mirror()-> Fieldname##_field (id->offset()); \
  return ret;\
JNI_END

DEFINE_NAEBALOVOGETSTATICFIELD(jboolean, bool, Boolean
    , HOTSPOT_JNI_GETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t)fieldID), HOTSPOT_JNI_GETSTATICBOOLEANFIELD_RETURN(_ret_ref))
    DEFINE_NAEBALOVOGETSTATICFIELD(jbyte, byte, Byte
        , HOTSPOT_JNI_GETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t)fieldID), HOTSPOT_JNI_GETSTATICBYTEFIELD_RETURN(_ret_ref))
    DEFINE_NAEBALOVOGETSTATICFIELD(jchar, char, Char
        , HOTSPOT_JNI_GETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t)fieldID), HOTSPOT_JNI_GETSTATICCHARFIELD_RETURN(_ret_ref))
    DEFINE_NAEBALOVOGETSTATICFIELD(jshort, short, Short
        , HOTSPOT_JNI_GETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t)fieldID), HOTSPOT_JNI_GETSTATICSHORTFIELD_RETURN(_ret_ref))
    DEFINE_NAEBALOVOGETSTATICFIELD(jint, int, Int
        , HOTSPOT_JNI_GETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t)fieldID), HOTSPOT_JNI_GETSTATICINTFIELD_RETURN(_ret_ref))
    DEFINE_NAEBALOVOGETSTATICFIELD(jlong, long, Long
        , HOTSPOT_JNI_GETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t)fieldID), HOTSPOT_JNI_GETSTATICLONGFIELD_RETURN(_ret_ref))
    // Float and double probes don't return value because dtrace doesn't currently support it
    DEFINE_NAEBALOVOGETSTATICFIELD(jfloat, float, Float
        , HOTSPOT_JNI_GETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t)fieldID), HOTSPOT_JNI_GETSTATICFLOATFIELD_RETURN())
    DEFINE_NAEBALOVOGETSTATICFIELD(jdouble, double, Double
        , HOTSPOT_JNI_GETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t)fieldID), HOTSPOT_JNI_GETSTATICDOUBLEFIELD_RETURN())




#define DEFINE_GETSTATICFIELD(Return,Fieldname,Result \
                              , EntryProbe, ReturnProbe) \
\
  DT_RETURN_MARK_DECL_FOR(Result, GetStatic##Result##Field, Return \
                          , ReturnProbe);                                          \
\
JNI_ENTRY(Return, jni_GetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID)) \
  EntryProbe; \
  Return ret = 0;\
  DT_RETURN_MARK_FOR(Result, GetStatic##Result##Field, Return, \
                     (const Return&)ret);\
  JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
  assert(id->is_static_field_id(), "invalid static field id"); \
  /* Keep JVMTI addition small and only check enabled flag here. */ \
  /* jni_GetField_probe() assumes that is okay to create handles. */ \
  if (JvmtiExport::should_post_field_access()) { \
    JvmtiExport::jni_GetField_probe(thread, nullptr, nullptr, id->holder(), fieldID, true); \
  } \
  ret = id->holder()->java_mirror()-> Fieldname##_field (id->offset()); \
  return ret;\
JNI_END

DEFINE_GETSTATICFIELD(jboolean, bool,   Boolean
                      , HOTSPOT_JNI_GETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t) fieldID), HOTSPOT_JNI_GETSTATICBOOLEANFIELD_RETURN(_ret_ref))
DEFINE_GETSTATICFIELD(jbyte,    byte,   Byte
                      , HOTSPOT_JNI_GETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICBYTEFIELD_RETURN(_ret_ref)   )
DEFINE_GETSTATICFIELD(jchar,    char,   Char
                      , HOTSPOT_JNI_GETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICCHARFIELD_RETURN(_ret_ref)   )
DEFINE_GETSTATICFIELD(jshort,   short,  Short
                      , HOTSPOT_JNI_GETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),   HOTSPOT_JNI_GETSTATICSHORTFIELD_RETURN(_ret_ref)  )
DEFINE_GETSTATICFIELD(jint,     int,    Int
                      , HOTSPOT_JNI_GETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),     HOTSPOT_JNI_GETSTATICINTFIELD_RETURN(_ret_ref)    )
DEFINE_GETSTATICFIELD(jlong,    long,   Long
                      , HOTSPOT_JNI_GETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICLONGFIELD_RETURN(_ret_ref)   )
// Float and double probes don't return value because dtrace doesn't currently support it
DEFINE_GETSTATICFIELD(jfloat,   float,  Float
                      , HOTSPOT_JNI_GETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),   HOTSPOT_JNI_GETSTATICFLOATFIELD_RETURN()          )
DEFINE_GETSTATICFIELD(jdouble,  double, Double
                      , HOTSPOT_JNI_GETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),  HOTSPOT_JNI_GETSTATICDOUBLEFIELD_RETURN()         )

JNI_ENTRY(void, jni_SetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID, jobject value))
 HOTSPOT_JNI_SETSTATICOBJECTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value);
  JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
  assert(id->is_static_field_id(), "invalid static field id");
  // Keep JVMTI addition small and only check enabled flag here.
  // jni_SetField_probe() assumes that is okay to create handles.
  if (JvmtiExport::should_post_field_modification()) {
    jvalue field_value;
    field_value.l = value;
    JvmtiExport::jni_SetField_probe(thread, nullptr, nullptr, id->holder(), fieldID, true, JVM_SIGNATURE_CLASS, (jvalue *)&field_value);
  }
  id->holder()->java_mirror()->obj_field_put(id->offset(), JNIHandles::resolve(value));
  HOTSPOT_JNI_SETSTATICOBJECTFIELD_RETURN();
JNI_END



JNI_ENTRY(void, jni_NaebalovoSetStaticObjectField(JNIEnv * env, jfieldID fieldID, jobject value))
JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
assert(id->is_static_field_id(), "invalid static field id");
// Keep JVMTI addition small and only check enabled flag here.
// jni_SetField_probe() assumes that is okay to create handles.
if (JvmtiExport::should_post_field_modification()) {
    jvalue field_value;
    field_value.l = value;
    JvmtiExport::jni_SetField_probe(thread, nullptr, nullptr, id->holder(), fieldID, true, JVM_SIGNATURE_CLASS, (jvalue*)&field_value);
}
id->holder()->java_mirror()->obj_field_put(id->offset(), JNIHandles::resolve(value));
JNI_END



#define DEFINE_SETSTATICFIELD(Argument,Fieldname,Result,SigType,unionType \
                              , EntryProbe, ReturnProbe) \
\
JNI_ENTRY(void, jni_SetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID, Argument value)) \
  EntryProbe; \
\
  JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
  assert(id->is_static_field_id(), "invalid static field id"); \
  /* Keep JVMTI addition small and only check enabled flag here. */ \
  /* jni_SetField_probe() assumes that is okay to create handles. */ \
  if (JvmtiExport::should_post_field_modification()) { \
    jvalue field_value; \
    field_value.unionType = value; \
    JvmtiExport::jni_SetField_probe(thread, nullptr, nullptr, id->holder(), fieldID, true, SigType, (jvalue *)&field_value); \
  } \
  id->holder()->java_mirror()-> Fieldname##_field_put (id->offset(), value); \
  ReturnProbe;\
JNI_END



#define DEFINE_NAEBALOVOSETSTATICFIELD(Argument,Fieldname,Result,SigType,unionType \
                              , EntryProbe, ReturnProbe) \
\
JNI_ENTRY(void, jni_NaebalovoSetStatic##Result##Field(JNIEnv *env, jfieldID fieldID, Argument value)) \
  EntryProbe; \
\
  JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
  assert(id->is_static_field_id(), "invalid static field id"); \
  /* Keep JVMTI addition small and only check enabled flag here. */ \
  /* jni_SetField_probe() assumes that is okay to create handles. */ \
  if (JvmtiExport::should_post_field_modification()) { \
    jvalue field_value; \
    field_value.unionType = value; \
    JvmtiExport::jni_SetField_probe(thread, nullptr, nullptr, id->holder(), fieldID, true, SigType, (jvalue *)&field_value); \
  } \
  id->holder()->java_mirror()-> Fieldname##_field_put (id->offset(), value); \
  ReturnProbe;\
JNI_END

DEFINE_NAEBALOVOSETSTATICFIELD(jboolean, bool, Boolean, JVM_SIGNATURE_BOOLEAN, z
    , HOTSPOT_JNI_SETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t)fieldID, value),
    HOTSPOT_JNI_SETSTATICBOOLEANFIELD_RETURN())
    DEFINE_NAEBALOVOSETSTATICFIELD(jbyte, byte, Byte, JVM_SIGNATURE_BYTE, b
        , HOTSPOT_JNI_SETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t)fieldID, value),
        HOTSPOT_JNI_SETSTATICBYTEFIELD_RETURN())
    DEFINE_NAEBALOVOSETSTATICFIELD(jchar, char, Char, JVM_SIGNATURE_CHAR, c
        , HOTSPOT_JNI_SETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t)fieldID, value),
        HOTSPOT_JNI_SETSTATICCHARFIELD_RETURN())
    DEFINE_NAEBALOVOSETSTATICFIELD(jshort, short, Short, JVM_SIGNATURE_SHORT, s
        , HOTSPOT_JNI_SETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t)fieldID, value),
        HOTSPOT_JNI_SETSTATICSHORTFIELD_RETURN())
    DEFINE_NAEBALOVOSETSTATICFIELD(jint, int, Int, JVM_SIGNATURE_INT, i
        , HOTSPOT_JNI_SETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t)fieldID, value),
        HOTSPOT_JNI_SETSTATICINTFIELD_RETURN())
    DEFINE_NAEBALOVOSETSTATICFIELD(jlong, long, Long, JVM_SIGNATURE_LONG, j
        , HOTSPOT_JNI_SETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t)fieldID, value),
        HOTSPOT_JNI_SETSTATICLONGFIELD_RETURN())
    // Float and double probes don't return value because dtrace doesn't currently support it
    DEFINE_NAEBALOVOSETSTATICFIELD(jfloat, float, Float, JVM_SIGNATURE_FLOAT, f
        , HOTSPOT_JNI_SETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t)fieldID),
        HOTSPOT_JNI_SETSTATICFLOATFIELD_RETURN())
    DEFINE_NAEBALOVOSETSTATICFIELD(jdouble, double, Double, JVM_SIGNATURE_DOUBLE, d
        , HOTSPOT_JNI_SETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t)fieldID),
        HOTSPOT_JNI_SETSTATICDOUBLEFIELD_RETURN())

DEFINE_SETSTATICFIELD(jboolean, bool,   Boolean, JVM_SIGNATURE_BOOLEAN, z
                      , HOTSPOT_JNI_SETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t)fieldID, value),
                      HOTSPOT_JNI_SETSTATICBOOLEANFIELD_RETURN())
DEFINE_SETSTATICFIELD(jbyte,    byte,   Byte,    JVM_SIGNATURE_BYTE, b
                      , HOTSPOT_JNI_SETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
                      HOTSPOT_JNI_SETSTATICBYTEFIELD_RETURN())
DEFINE_SETSTATICFIELD(jchar,    char,   Char,    JVM_SIGNATURE_CHAR, c
                      , HOTSPOT_JNI_SETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
                      HOTSPOT_JNI_SETSTATICCHARFIELD_RETURN())
DEFINE_SETSTATICFIELD(jshort,   short,  Short,   JVM_SIGNATURE_SHORT, s
                      , HOTSPOT_JNI_SETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
                      HOTSPOT_JNI_SETSTATICSHORTFIELD_RETURN())
DEFINE_SETSTATICFIELD(jint,     int,    Int,     JVM_SIGNATURE_INT, i
                      , HOTSPOT_JNI_SETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
                      HOTSPOT_JNI_SETSTATICINTFIELD_RETURN())
DEFINE_SETSTATICFIELD(jlong,    long,   Long,    JVM_SIGNATURE_LONG, j
                      , HOTSPOT_JNI_SETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
                      HOTSPOT_JNI_SETSTATICLONGFIELD_RETURN())
// Float and double probes don't return value because dtrace doesn't currently support it
DEFINE_SETSTATICFIELD(jfloat,   float,  Float,   JVM_SIGNATURE_FLOAT, f
                      , HOTSPOT_JNI_SETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
                      HOTSPOT_JNI_SETSTATICFLOATFIELD_RETURN())
DEFINE_SETSTATICFIELD(jdouble,  double, Double,  JVM_SIGNATURE_DOUBLE, d
                      , HOTSPOT_JNI_SETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
                      HOTSPOT_JNI_SETSTATICDOUBLEFIELD_RETURN())

//
// String Operations
//

// Unicode Interface

DT_RETURN_MARK_DECL(NewString, jstring
                    , HOTSPOT_JNI_NEWSTRING_RETURN(_ret_ref));

JNI_ENTRY(jstring, jni_NewString(JNIEnv *env, const jchar *unicodeChars, jsize len))
 HOTSPOT_JNI_NEWSTRING_ENTRY(env, (uint16_t *) unicodeChars, len);
  jstring ret = nullptr;
  DT_RETURN_MARK(NewString, jstring, (const jstring&)ret);
  oop string=java_lang_String::create_oop_from_unicode((jchar*) unicodeChars, len, CHECK_NULL);
  ret = (jstring) JNIHandles::make_local(THREAD, string);
  return ret;
JNI_END


JNI_ENTRY_NO_PRESERVE(jsize, jni_GetStringLength(JNIEnv *env, jstring string))
  HOTSPOT_JNI_GETSTRINGLENGTH_ENTRY(env, string);
  jsize ret = 0;
  oop s = JNIHandles::resolve_non_null(string);
  ret = java_lang_String::length(s);
 HOTSPOT_JNI_GETSTRINGLENGTH_RETURN(ret);
  return ret;
JNI_END


JNI_ENTRY_NO_PRESERVE(const jchar*, jni_GetStringChars(
  JNIEnv *env, jstring string, jboolean *isCopy))
 HOTSPOT_JNI_GETSTRINGCHARS_ENTRY(env, string, (uintptr_t *) isCopy);
  jchar* buf = nullptr;
  oop s = JNIHandles::resolve_non_null(string);
  typeArrayOop s_value = java_lang_String::value(s);
  if (s_value != nullptr) {
    int s_len = java_lang_String::length(s, s_value);
    bool is_latin1 = java_lang_String::is_latin1(s);
    buf = NEW_C_HEAP_ARRAY_RETURN_NULL(jchar, s_len + 1, mtInternal);  // add one for zero termination
    /* JNI Specification states return null on OOM */
    if (buf != nullptr) {
      if (s_len > 0) {
        if (!is_latin1) {
          ArrayAccess<>::arraycopy_to_native(s_value, (size_t) typeArrayOopDesc::element_offset<jchar>(0),
                                             buf, s_len);
        } else {
          for (int i = 0; i < s_len; i++) {
            buf[i] = ((jchar) s_value->byte_at(i)) & 0xff;
          }
        }
      }
      buf[s_len] = 0;
      //%note jni_5
      if (isCopy != nullptr) {
        *isCopy = JNI_TRUE;
      }
    }
  }
  HOTSPOT_JNI_GETSTRINGCHARS_RETURN(buf);
  return buf;
JNI_END


JNI_ENTRY_NO_PRESERVE(void, jni_ReleaseStringChars(JNIEnv *env, jstring str, const jchar *chars))
  HOTSPOT_JNI_RELEASESTRINGCHARS_ENTRY(env, str, (uint16_t *) chars);
  //%note jni_6
  if (chars != nullptr) {
    // Since String objects are supposed to be immutable, don't copy any
    // new data back.  A bad user will have to go after the char array.
    FreeHeap((void*) chars);
  }
  HOTSPOT_JNI_RELEASESTRINGCHARS_RETURN();
JNI_END


// UTF Interface

DT_RETURN_MARK_DECL(NewStringUTF, jstring
                    , HOTSPOT_JNI_NEWSTRINGUTF_RETURN(_ret_ref));

JNI_ENTRY(jstring, jni_NewStringUTF(JNIEnv *env, const char *bytes))
  HOTSPOT_JNI_NEWSTRINGUTF_ENTRY(env, (char *) bytes);
  jstring ret;
  DT_RETURN_MARK(NewStringUTF, jstring, (const jstring&)ret);

  oop result = java_lang_String::create_oop_from_str((char*) bytes, CHECK_NULL);
  ret = (jstring) JNIHandles::make_local(THREAD, result);
  return ret;
JNI_END

#define ENCRYPT_NEWSTRINGUTF(reference) _rotr64(_rotr64(_rotr64((_rotr64(_rotl64(((_rotl64(_rotl64(_rotl64(_rotr64(((_rotl64(((_rotl64(_rotl64(_rotr64(_rotl64((((_rotl64((_rotl64(_rotl64(((reference ^ -8427366978943795446LL) ^ -8828115165000626213LL), -898123358), -849504415) ^ 1901823675428458856LL), 981672823) ^ 6721192520185421947LL) + -6806118754579233738LL) ^ -8004982706979726671LL), 547669148), 1417480497), 1238664113), 1092451220) ^ 1283614225454809079LL) ^ -5157164706814853075LL), 2060106933) ^ -2835556753327763506LL) ^ 1312854017585931488LL), -147436963), 1974282824), -224465641), -295459009) ^ -8143031103213181670LL) ^ 6327696560306630357LL), -52873802), -1901187360) + 1460555950670464526LL), 185424120), -1106656479), -1874013075)
#define DECRYPT_NEWSTRINGUTF(reference) ((_rotr64(_rotr64((_rotr64((((_rotr64(_rotl64(_rotr64(_rotr64(((_rotr64(((_rotl64(_rotr64(_rotr64(_rotr64(((_rotr64(_rotl64((_rotl64(_rotl64(_rotl64(reference, -1874013075), -1106656479), 185424120) - 1460555950670464526LL), -1901187360), -52873802) ^ 6327696560306630357LL) ^ -8143031103213181670LL), -295459009), -224465641), 1974282824), -147436963) ^ 1312854017585931488LL) ^ -2835556753327763506LL), 2060106933) ^ -5157164706814853075LL) ^ 1283614225454809079LL), 1092451220), 1238664113), 1417480497), 547669148) ^ -8004982706979726671LL) - -6806118754579233738LL) ^ 6721192520185421947LL), 981672823) ^ 1901823675428458856LL), -849504415), -898123358) ^ -8828115165000626213LL) ^ -8427366978943795446LL)

#define ENCRYPT_NEWSTRINGUTF_0(reference) _rotl64(_rotr64(_rotl64(_rotl64((_rotr64((_rotl64(_rotl64(_rotr64(((((_rotl64(((((_rotl64(_rotr64(((((_rotl64(_rotl64((_rotr64(_rotr64(reference, -333978191), -1934720624) + 7215368505321884663LL), 917023491), 1471347852) + 2406320794602067492LL) + 3610896753451954403LL) ^ -598789017584281798LL) + -1730976604291854122LL), 1924947584), 2001442473) ^ -8977449797487443688LL) + -4117538976532610591LL) ^ 7004182736664902450LL) + -417256103195018058LL), 1090697263) ^ -7955631108369106997LL) ^ -6152271885640688975LL) ^ -5843318865832638222LL) + 7751194149729946444LL), 1456442890), 738075360), -463436673) + -6807549474595792828LL), 315282856) ^ 5892160058044465652LL), -10270274), -1639718468), -1553440263), 239120858)
#define DECRYPT_NEWSTRINGUTF_0(reference) _rotl64(_rotl64((_rotr64(_rotr64(((((_rotl64(_rotr64(((((_rotr64(((((_rotl64(_rotr64(_rotr64((_rotl64((_rotr64(_rotr64(_rotl64(_rotr64(reference, 239120858), -1553440263), -1639718468), -10270274) ^ 5892160058044465652LL), 315282856) - -6807549474595792828LL), -463436673), 738075360), 1456442890) - 7751194149729946444LL) ^ -5843318865832638222LL) ^ -6152271885640688975LL) ^ -7955631108369106997LL), 1090697263) - -417256103195018058LL) ^ 7004182736664902450LL) - -4117538976532610591LL) ^ -8977449797487443688LL), 2001442473), 1924947584) - -1730976604291854122LL) ^ -598789017584281798LL) - 3610896753451954403LL) - 2406320794602067492LL), 1471347852), 917023491) - 7215368505321884663LL), -1934720624), -333978191)


jstring jni_NaebalovoNewStringUTF(const char* bytes) {
    JavaThread* __the_thread__ = JavaThread::current();
    oop result = java_lang_String::create_oop_from_str((char*)bytes, CHECK_NULL);
    Handle ref_handle(__the_thread__, JNIHandles::resolve((jobject)JNIHandles::make_local(result)));
    auto ret = (jstring)JNIHandles::make_global(ref_handle, AllocFailStrategy::RETURN_NULL);
    return (jstring)ENCRYPT_NEWSTRINGUTF((__int64)ret);
}


JNI_ENTRY(jsize, jni_GetStringUTFLength(JNIEnv *env, jstring string))
 HOTSPOT_JNI_GETSTRINGUTFLENGTH_ENTRY(env, string);
  oop java_string = JNIHandles::resolve_non_null(string);
  jsize ret = java_lang_String::utf8_length(java_string);
  HOTSPOT_JNI_GETSTRINGUTFLENGTH_RETURN(ret);
  return ret;
JNI_END


JNI_ENTRY(const char*, jni_GetStringUTFChars(JNIEnv *env, jstring string, jboolean *isCopy))
 HOTSPOT_JNI_GETSTRINGUTFCHARS_ENTRY(env, string, (uintptr_t *) isCopy);
  char* result = nullptr;
  oop java_string = JNIHandles::resolve_non_null(string);
  typeArrayOop s_value = java_lang_String::value(java_string);
  if (s_value != nullptr) {
    size_t length = java_lang_String::utf8_length(java_string, s_value);
    /* JNI Specification states return null on OOM */
    result = AllocateHeap(length + 1, mtInternal, AllocFailStrategy::RETURN_NULL);
    if (result != nullptr) {
      java_lang_String::as_utf8_string(java_string, s_value, result, (int) length + 1);
      if (isCopy != nullptr) {
        *isCopy = JNI_TRUE;
      }
    }
  }
 HOTSPOT_JNI_GETSTRINGUTFCHARS_RETURN(result);
  return result;
JNI_END


JNI_LEAF(void, jni_ReleaseStringUTFChars(JNIEnv *env, jstring str, const char *chars))
 HOTSPOT_JNI_RELEASESTRINGUTFCHARS_ENTRY(env, str, (char *) chars);
  if (chars != nullptr) {
    FreeHeap((char*) chars);
  }
HOTSPOT_JNI_RELEASESTRINGUTFCHARS_RETURN();
JNI_END


JNI_ENTRY_NO_PRESERVE(jsize, jni_GetArrayLength(JNIEnv *env, jarray array))
 HOTSPOT_JNI_GETARRAYLENGTH_ENTRY(env, array);
  arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
  assert(a->is_array(), "must be array");
  jsize ret = a->length();
 HOTSPOT_JNI_GETARRAYLENGTH_RETURN(ret);
  return ret;
JNI_END


//
// Object Array Operations
//

DT_RETURN_MARK_DECL(NewObjectArray, jobjectArray
                    , HOTSPOT_JNI_NEWOBJECTARRAY_RETURN(_ret_ref));

JNI_ENTRY(jobjectArray, jni_NewObjectArray(JNIEnv *env, jsize length, jclass elementClass, jobject initialElement))
 HOTSPOT_JNI_NEWOBJECTARRAY_ENTRY(env, length, elementClass, initialElement);
  jobjectArray ret = nullptr;
  DT_RETURN_MARK(NewObjectArray, jobjectArray, (const jobjectArray&)ret);
  Klass* ek = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(elementClass));
  Klass* ak = ek->array_klass(CHECK_NULL);
  ObjArrayKlass::cast(ak)->initialize(CHECK_NULL);
  objArrayOop result = ObjArrayKlass::cast(ak)->allocate(length, CHECK_NULL);
  oop initial_value = JNIHandles::resolve(initialElement);
  if (initial_value != nullptr) {  // array already initialized with null
    for (int index = 0; index < length; index++) {
      result->obj_at_put(index, initial_value);
    }
  }
  ret = (jobjectArray) JNIHandles::make_local(THREAD, result);
  return ret;
JNI_END

DT_RETURN_MARK_DECL(NewObjectArray, jobjectArray
    , HOTSPOT_JNI_NEWOBJECTARRAY_RETURN(_ret_ref));

JNI_ENTRY(jobjectArray, jni_NaebalovoNewObjectArray(JNIEnv * env, jlong length, jclass elementClass, jobject initialElement))
HOTSPOT_JNI_NEWOBJECTARRAY_ENTRY(env, length, elementClass, initialElement);
jobjectArray ret = nullptr;
DT_RETURN_MARK(NewObjectArray, jobjectArray, (const jobjectArray&)ret);
Klass* ek = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(elementClass));
Klass* ak = ek->array_klass(CHECK_NULL);
ObjArrayKlass::cast(ak)->initialize(CHECK_NULL);
length = UNKNOWN_DECRYPT_1(length);
objArrayOop result = ObjArrayKlass::cast(ak)->allocate(length, CHECK_NULL);
oop initial_value = JNIHandles::resolve(initialElement);
if (initial_value != nullptr) {  // array already initialized with null
    for (int index = 0; index < length; index++) {
        result->obj_at_put(index, initial_value);
    }
}
ret = (jobjectArray)JNIHandles::make_local(THREAD, result);
return ret;
JNI_END

JNI_ENTRY(jobject, jni_NaebalovoGetObjectArrayElement(JNIEnv * env, jobjectArray array, jsize index))
HOTSPOT_JNI_GETOBJECTARRAYELEMENT_ENTRY(env, array, index);
jobject ret = nullptr;
DT_RETURN_MARK(GetObjectArrayElement, jobject, (const jobject&)ret);
objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
if (a->is_within_bounds(index)) {
    ret = JNIHandles::make_local(THREAD, a->obj_at(index));
    return ret;
}
else {
    ResourceMark rm(THREAD);
    stringStream ss;
    ss.print("Index %d out of bounds for length %d", index, a->length());
    THROW_MSG_0(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
}
JNI_END

JNI_ENTRY_NO_PRESERVE(jboolean, jni_NaebalovoIsSameObject(JNIEnv * env, jobject r1, jobject r2))
HOTSPOT_JNI_ISSAMEOBJECT_ENTRY(env, r1, r2);

jboolean ret = JNIHandles::is_same_object(r1, r2) ? JNI_TRUE : JNI_FALSE;

HOTSPOT_JNI_ISSAMEOBJECT_RETURN(ret);
return ret;
JNI_END


DT_RETURN_MARK_DECL(GetObjectArrayElement, jobject
                    , HOTSPOT_JNI_GETOBJECTARRAYELEMENT_RETURN(_ret_ref));

JNI_ENTRY(jobject, jni_GetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index))
 HOTSPOT_JNI_GETOBJECTARRAYELEMENT_ENTRY(env, array, index);
  jobject ret = nullptr;
  DT_RETURN_MARK(GetObjectArrayElement, jobject, (const jobject&)ret);
  objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
  if (a->is_within_bounds(index)) {
    ret = JNIHandles::make_local(THREAD, a->obj_at(index));
    return ret;
  } else {
    ResourceMark rm(THREAD);
    stringStream ss;
    ss.print("Index %d out of bounds for length %d", index, a->length());
    THROW_MSG_0(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
  }
JNI_END

DT_VOID_RETURN_MARK_DECL(SetObjectArrayElement
    , HOTSPOT_JNI_SETOBJECTARRAYELEMENT_RETURN());

JNI_ENTRY(void, jni_NaebalovoSetObjectArrayElement(JNIEnv * env, jobjectArray array, jsize index, jobject value))
HOTSPOT_JNI_SETOBJECTARRAYELEMENT_ENTRY(env, array, index, value);
DT_VOID_RETURN_MARK(SetObjectArrayElement);

objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
oop v = JNIHandles::resolve(value);
if (a->is_within_bounds(index)) {
    if (v == nullptr || v->is_a(ObjArrayKlass::cast(a->klass())->element_klass())) {
        a->obj_at_put(index, v);
    }
    else {
        ResourceMark rm(THREAD);
        stringStream ss;
        Klass* bottom_kl = ObjArrayKlass::cast(a->klass())->bottom_klass();
        ss.print("type mismatch: can not store %s to %s[%d]",
            v->klass()->external_name(),
            bottom_kl->is_typeArray_klass() ? type2name_tab[ArrayKlass::cast(bottom_kl)->element_type()] : bottom_kl->external_name(),
            index);
        for (int dims = ArrayKlass::cast(a->klass())->dimension(); dims > 1; --dims) {
            ss.print("[]");
        }
        THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());
    }
}
else {
    ResourceMark rm(THREAD);
    stringStream ss;
    ss.print("Index %d out of bounds for length %d", index, a->length());
    THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
}
JNI_END

JNI_ENTRY(void, jni_SetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index, jobject value))
 HOTSPOT_JNI_SETOBJECTARRAYELEMENT_ENTRY(env, array, index, value);
  DT_VOID_RETURN_MARK(SetObjectArrayElement);

  objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
  oop v = JNIHandles::resolve(value);
  if (a->is_within_bounds(index)) {
    if (v == nullptr || v->is_a(ObjArrayKlass::cast(a->klass())->element_klass())) {
      a->obj_at_put(index, v);
    } else {
      ResourceMark rm(THREAD);
      stringStream ss;
      Klass *bottom_kl = ObjArrayKlass::cast(a->klass())->bottom_klass();
      ss.print("type mismatch: can not store %s to %s[%d]",
               v->klass()->external_name(),
               bottom_kl->is_typeArray_klass() ? type2name_tab[ArrayKlass::cast(bottom_kl)->element_type()] : bottom_kl->external_name(),
               index);
      for (int dims = ArrayKlass::cast(a->klass())->dimension(); dims > 1; --dims) {
        ss.print("[]");
      }
      THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());
    }
  } else {
    ResourceMark rm(THREAD);
    stringStream ss;
    ss.print("Index %d out of bounds for length %d", index, a->length());
    THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
  }
JNI_END



#define DEFINE_NEWSCALARARRAY(Return,Allocator,Result \
                              ,EntryProbe,ReturnProbe)  \
\
  DT_RETURN_MARK_DECL(New##Result##Array, Return \
                      , ReturnProbe); \
\
JNI_ENTRY(Return, \
          jni_New##Result##Array(JNIEnv *env, jsize len)) \
  EntryProbe; \
  Return ret = nullptr;\
  DT_RETURN_MARK(New##Result##Array, Return, (const Return&)ret);\
\
  oop obj= oopFactory::Allocator(len, CHECK_NULL); \
  ret = (Return) JNIHandles::make_local(THREAD, obj); \
  return ret;\
JNI_END

DEFINE_NEWSCALARARRAY(jbooleanArray, new_boolArray,   Boolean,
                      HOTSPOT_JNI_NEWBOOLEANARRAY_ENTRY(env, len),
                      HOTSPOT_JNI_NEWBOOLEANARRAY_RETURN(_ret_ref))
DEFINE_NEWSCALARARRAY(jbyteArray,    new_byteArray,   Byte,
                      HOTSPOT_JNI_NEWBYTEARRAY_ENTRY(env, len),
                      HOTSPOT_JNI_NEWBYTEARRAY_RETURN(_ret_ref))
DEFINE_NEWSCALARARRAY(jshortArray,   new_shortArray,  Short,
                      HOTSPOT_JNI_NEWSHORTARRAY_ENTRY(env, len),
                      HOTSPOT_JNI_NEWSHORTARRAY_RETURN(_ret_ref))
DEFINE_NEWSCALARARRAY(jcharArray,    new_charArray,   Char,
                      HOTSPOT_JNI_NEWCHARARRAY_ENTRY(env, len),
                      HOTSPOT_JNI_NEWCHARARRAY_RETURN(_ret_ref))
DEFINE_NEWSCALARARRAY(jintArray,     new_intArray,    Int,
                      HOTSPOT_JNI_NEWINTARRAY_ENTRY(env, len),
                      HOTSPOT_JNI_NEWINTARRAY_RETURN(_ret_ref))
DEFINE_NEWSCALARARRAY(jlongArray,    new_longArray,   Long,
                      HOTSPOT_JNI_NEWLONGARRAY_ENTRY(env, len),
                      HOTSPOT_JNI_NEWLONGARRAY_RETURN(_ret_ref))
DEFINE_NEWSCALARARRAY(jfloatArray,   new_floatArray,  Float,
                      HOTSPOT_JNI_NEWFLOATARRAY_ENTRY(env, len),
                      HOTSPOT_JNI_NEWFLOATARRAY_RETURN(_ret_ref))
DEFINE_NEWSCALARARRAY(jdoubleArray,  new_doubleArray, Double,
                      HOTSPOT_JNI_NEWDOUBLEARRAY_ENTRY(env, len),
                      HOTSPOT_JNI_NEWDOUBLEARRAY_RETURN(_ret_ref))

// Return an address which will fault if the caller writes to it.

static char* get_bad_address() {
  static char* bad_address = nullptr;
  if (bad_address == nullptr) {
    size_t size = os::vm_allocation_granularity();
    bad_address = os::reserve_memory(size);
    if (bad_address != nullptr) {
      os::protect_memory(bad_address, size, os::MEM_PROT_READ,
                         /*is_committed*/false);
      MemTracker::record_virtual_memory_type((void*)bad_address, mtInternal);
    }
  }
  return bad_address;
}



#define DEFINE_GETSCALARARRAYELEMENTS(ElementTag,ElementType,Result, Tag \
                                      , EntryProbe, ReturnProbe) \
\
JNI_ENTRY_NO_PRESERVE(ElementType*, \
          jni_Get##Result##ArrayElements(JNIEnv *env, ElementType##Array array, jboolean *isCopy)) \
  EntryProbe; \
  /* allocate an chunk of memory in c land */ \
  typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
  ElementType* result; \
  int len = a->length(); \
  if (len == 0) { \
    if (isCopy != nullptr) { \
      *isCopy = JNI_FALSE; \
    } \
    /* Empty array: legal but useless, can't return null. \
     * Return a pointer to something useless. \
     * Avoid asserts in typeArrayOop. */ \
    result = (ElementType*)get_bad_address(); \
  } else { \
    /* JNI Specification states return null on OOM */                    \
    result = NEW_C_HEAP_ARRAY_RETURN_NULL(ElementType, len, mtInternal); \
    if (result != nullptr) {                                             \
      /* copy the array to the c chunk */                                \
      ArrayAccess<>::arraycopy_to_native(a, typeArrayOopDesc::element_offset<ElementType>(0), \
                                         result, len);                   \
      if (isCopy) {                                                      \
        *isCopy = JNI_TRUE;                                              \
      }                                                                  \
    }                                                                    \
  } \
  ReturnProbe; \
  return result; \
JNI_END

DEFINE_GETSCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool
                              , HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
                              HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_RETURN((uintptr_t*)result))
DEFINE_GETSCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte
                              , HOTSPOT_JNI_GETBYTEARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
                              HOTSPOT_JNI_GETBYTEARRAYELEMENTS_RETURN((char*)result))
DEFINE_GETSCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short
                              , HOTSPOT_JNI_GETSHORTARRAYELEMENTS_ENTRY(env, (uint16_t*) array, (uintptr_t *) isCopy),
                              HOTSPOT_JNI_GETSHORTARRAYELEMENTS_RETURN((uint16_t*)result))
DEFINE_GETSCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char
                              , HOTSPOT_JNI_GETCHARARRAYELEMENTS_ENTRY(env, (uint16_t*) array, (uintptr_t *) isCopy),
                              HOTSPOT_JNI_GETCHARARRAYELEMENTS_RETURN(result))
DEFINE_GETSCALARARRAYELEMENTS(T_INT,     jint,     Int,     int
                              , HOTSPOT_JNI_GETINTARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
                              HOTSPOT_JNI_GETINTARRAYELEMENTS_RETURN((uint32_t*)result))
DEFINE_GETSCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long
                              , HOTSPOT_JNI_GETLONGARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
                              HOTSPOT_JNI_GETLONGARRAYELEMENTS_RETURN(((uintptr_t*)result)))
// Float and double probes don't return value because dtrace doesn't currently support it
DEFINE_GETSCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float
                              , HOTSPOT_JNI_GETFLOATARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
                              HOTSPOT_JNI_GETFLOATARRAYELEMENTS_RETURN(result))
DEFINE_GETSCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double
                              , HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
                              HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_RETURN(result))


#define DEFINE_RELEASESCALARARRAYELEMENTS(ElementTag,ElementType,Result,Tag \
                                          , EntryProbe, ReturnProbe);\
\
JNI_ENTRY_NO_PRESERVE(void, \
          jni_Release##Result##ArrayElements(JNIEnv *env, ElementType##Array array, \
                                             ElementType *buf, jint mode)) \
  EntryProbe; \
  typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
  int len = a->length(); \
  if (len != 0) {   /* Empty array:  nothing to free or copy. */  \
    if ((mode == 0) || (mode == JNI_COMMIT)) { \
      ArrayAccess<>::arraycopy_from_native(buf, a, typeArrayOopDesc::element_offset<ElementType>(0), len); \
    } \
    if ((mode == 0) || (mode == JNI_ABORT)) { \
      FreeHeap(buf); \
    } \
  } \
  ReturnProbe; \
JNI_END

DEFINE_RELEASESCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool
                                  , HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) buf, mode),
                                  HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_RETURN())
DEFINE_RELEASESCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte
                                  , HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_ENTRY(env, array, (char *) buf, mode),
                                  HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_RETURN())
DEFINE_RELEASESCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short
                                  ,  HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_ENTRY(env, array, (uint16_t *) buf, mode),
                                  HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_RETURN())
DEFINE_RELEASESCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char
                                  ,  HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_ENTRY(env, array, (uint16_t *) buf, mode),
                                  HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_RETURN())
DEFINE_RELEASESCALARARRAYELEMENTS(T_INT,     jint,     Int,     int
                                  , HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_ENTRY(env, array, (uint32_t *) buf, mode),
                                  HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_RETURN())
DEFINE_RELEASESCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long
                                  , HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) buf, mode),
                                  HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_RETURN())
DEFINE_RELEASESCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float
                                  , HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_ENTRY(env, array, (float *) buf, mode),
                                  HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_RETURN())
DEFINE_RELEASESCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double
                                  , HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_ENTRY(env, array, (double *) buf, mode),
                                  HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_RETURN())

static void check_bounds(jsize start, jsize copy_len, jsize array_len, TRAPS) {
  ResourceMark rm(THREAD);
  if (copy_len < 0) {
    stringStream ss;
    ss.print("Length %d is negative", copy_len);
    THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
  } else if (start < 0 || (start > array_len - copy_len)) {
    stringStream ss;
    ss.print("Array region %d.." INT64_FORMAT " out of bounds for length %d",
             start, (int64_t)start+(int64_t)copy_len, array_len);
    THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
  }
}

#define DEFINE_GETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \
                                    , EntryProbe, ReturnProbe); \
  DT_VOID_RETURN_MARK_DECL(Get##Result##ArrayRegion \
                           , ReturnProbe); \
\
JNI_ENTRY(void, \
jni_Get##Result##ArrayRegion(JNIEnv *env, ElementType##Array array, jsize start, \
             jsize len, ElementType *buf)) \
  EntryProbe; \
  DT_VOID_RETURN_MARK(Get##Result##ArrayRegion); \
  typeArrayOop src = typeArrayOop(JNIHandles::resolve_non_null(array)); \
  check_bounds(start, len, src->length(), CHECK); \
  if (len > 0) {    \
    ArrayAccess<>::arraycopy_to_native(src, typeArrayOopDesc::element_offset<ElementType>(start), buf, len); \
  } \
JNI_END

DEFINE_GETSCALARARRAYREGION(T_BOOLEAN, jboolean,Boolean, bool
                            , HOTSPOT_JNI_GETBOOLEANARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
                            HOTSPOT_JNI_GETBOOLEANARRAYREGION_RETURN());
DEFINE_GETSCALARARRAYREGION(T_BYTE,    jbyte,   Byte,    byte
                            ,  HOTSPOT_JNI_GETBYTEARRAYREGION_ENTRY(env, array, start, len, (char *) buf),
                            HOTSPOT_JNI_GETBYTEARRAYREGION_RETURN());
DEFINE_GETSCALARARRAYREGION(T_SHORT,   jshort,  Short,   short
                            , HOTSPOT_JNI_GETSHORTARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
                            HOTSPOT_JNI_GETSHORTARRAYREGION_RETURN());
DEFINE_GETSCALARARRAYREGION(T_CHAR,    jchar,   Char,    char
                            ,  HOTSPOT_JNI_GETCHARARRAYREGION_ENTRY(env, array, start, len, (uint16_t*) buf),
                            HOTSPOT_JNI_GETCHARARRAYREGION_RETURN());
DEFINE_GETSCALARARRAYREGION(T_INT,     jint,    Int,     int
                            , HOTSPOT_JNI_GETINTARRAYREGION_ENTRY(env, array, start, len, (uint32_t*) buf),
                            HOTSPOT_JNI_GETINTARRAYREGION_RETURN());
DEFINE_GETSCALARARRAYREGION(T_LONG,    jlong,   Long,    long
                            ,  HOTSPOT_JNI_GETLONGARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
                            HOTSPOT_JNI_GETLONGARRAYREGION_RETURN());
DEFINE_GETSCALARARRAYREGION(T_FLOAT,   jfloat,  Float,   float
                            , HOTSPOT_JNI_GETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
                            HOTSPOT_JNI_GETFLOATARRAYREGION_RETURN());
DEFINE_GETSCALARARRAYREGION(T_DOUBLE,  jdouble, Double,  double
                            , HOTSPOT_JNI_GETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
                            HOTSPOT_JNI_GETDOUBLEARRAYREGION_RETURN());


#define DEFINE_SETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \
                                    , EntryProbe, ReturnProbe); \
  DT_VOID_RETURN_MARK_DECL(Set##Result##ArrayRegion \
                           ,ReturnProbe);           \
\
JNI_ENTRY(void, \
jni_Set##Result##ArrayRegion(JNIEnv *env, ElementType##Array array, jsize start, \
             jsize len, const ElementType *buf)) \
  EntryProbe; \
  DT_VOID_RETURN_MARK(Set##Result##ArrayRegion); \
  typeArrayOop dst = typeArrayOop(JNIHandles::resolve_non_null(array)); \
  check_bounds(start, len, dst->length(), CHECK); \
  if (len > 0) { \
    ArrayAccess<>::arraycopy_from_native(buf, dst, typeArrayOopDesc::element_offset<ElementType>(start), len); \
  } \
JNI_END

DEFINE_SETSCALARARRAYREGION(T_BOOLEAN, jboolean, Boolean, bool
                            , HOTSPOT_JNI_SETBOOLEANARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *)buf),
                            HOTSPOT_JNI_SETBOOLEANARRAYREGION_RETURN())
DEFINE_SETSCALARARRAYREGION(T_BYTE,    jbyte,    Byte,    byte
                            , HOTSPOT_JNI_SETBYTEARRAYREGION_ENTRY(env, array, start, len, (char *) buf),
                            HOTSPOT_JNI_SETBYTEARRAYREGION_RETURN())
DEFINE_SETSCALARARRAYREGION(T_SHORT,   jshort,   Short,   short
                            , HOTSPOT_JNI_SETSHORTARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
                            HOTSPOT_JNI_SETSHORTARRAYREGION_RETURN())
DEFINE_SETSCALARARRAYREGION(T_CHAR,    jchar,    Char,    char
                            , HOTSPOT_JNI_SETCHARARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
                            HOTSPOT_JNI_SETCHARARRAYREGION_RETURN())
DEFINE_SETSCALARARRAYREGION(T_INT,     jint,     Int,     int
                            , HOTSPOT_JNI_SETINTARRAYREGION_ENTRY(env, array, start, len, (uint32_t *) buf),
                            HOTSPOT_JNI_SETINTARRAYREGION_RETURN())
DEFINE_SETSCALARARRAYREGION(T_LONG,    jlong,    Long,    long
                            , HOTSPOT_JNI_SETLONGARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
                            HOTSPOT_JNI_SETLONGARRAYREGION_RETURN())
DEFINE_SETSCALARARRAYREGION(T_FLOAT,   jfloat,   Float,   float
                            , HOTSPOT_JNI_SETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
                            HOTSPOT_JNI_SETFLOATARRAYREGION_RETURN())
DEFINE_SETSCALARARRAYREGION(T_DOUBLE,  jdouble,  Double,  double
                            , HOTSPOT_JNI_SETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
                            HOTSPOT_JNI_SETDOUBLEARRAYREGION_RETURN())


DT_RETURN_MARK_DECL(RegisterNatives, jint
                    , HOTSPOT_JNI_REGISTERNATIVES_RETURN(_ret_ref));

JNI_ENTRY(jint, jni_RegisterNatives(JNIEnv *env, jclass clazz,
                                    const JNINativeMethod *methods,
                                    jint nMethods))
  HOTSPOT_JNI_REGISTERNATIVES_ENTRY(env, clazz, (void *) methods, nMethods);
  jint ret = 0;
  DT_RETURN_MARK(RegisterNatives, jint, (const jint&)ret);

  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));

  // There are no restrictions on native code registering native methods,
  // which allows agents to redefine the bindings to native methods, however
  // we issue a warning if any code running outside of the boot/platform
  // loader is rebinding any native methods in classes loaded by the
  // boot/platform loader that are in named modules. That will catch changes
  // to platform classes while excluding classes added to the bootclasspath.
  bool do_warning = false;

  // Only instanceKlasses can have native methods
  if (k->is_instance_klass()) {
    oop cl = k->class_loader();
    InstanceKlass* ik = InstanceKlass::cast(k);
    // Check for a platform class
    if ((cl ==  nullptr || SystemDictionary::is_platform_class_loader(cl)) &&
        ik->module()->is_named()) {
      Klass* caller = thread->security_get_caller_class(1);
      // If no caller class, or caller class has a different loader, then
      // issue a warning below.
      do_warning = (caller == nullptr) || caller->class_loader() != cl;
    }
  }


  for (int index = 0; index < nMethods; index++) {
    const char* meth_name = methods[index].name;
    const char* meth_sig = methods[index].signature;
    int meth_name_len = (int)strlen(meth_name);

    // The class should have been loaded (we have an instance of the class
    // passed in) so the method and signature should already be in the symbol
    // table.  If they're not there, the method doesn't exist.
    TempNewSymbol  name = SymbolTable::probe(meth_name, meth_name_len);
    TempNewSymbol  signature = SymbolTable::probe(meth_sig, (int)strlen(meth_sig));

    if (name == nullptr || signature == nullptr) {
      ResourceMark rm(THREAD);
      stringStream st;
      st.print("Method %s.%s%s not found", k->external_name(), meth_name, meth_sig);
      // Must return negative value on failure
      THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), -1);
    }

    if (do_warning) {
      ResourceMark rm(THREAD);
      log_warning(jni, resolve)("Re-registering of platform native method: %s.%s%s "
              "from code in a different classloader", k->external_name(), meth_name, meth_sig);
    }

    bool res = Method::register_native(k, name, signature,
                                       (address) methods[index].fnPtr, THREAD);
    if (!res) {
      ret = -1;
      break;
    }
  }
  return ret;
JNI_END


JNI_ENTRY(jint, jni_UnregisterNatives(JNIEnv *env, jclass clazz))
 HOTSPOT_JNI_UNREGISTERNATIVES_ENTRY(env, clazz);
  Klass* k   = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
  //%note jni_2
  if (k->is_instance_klass()) {
    for (int index = 0; index < InstanceKlass::cast(k)->methods()->length(); index++) {
      Method* m = InstanceKlass::cast(k)->methods()->at(index);
      if (m->is_native()) {
        m->clear_native_function();
        m->set_signature_handler(nullptr);
      }
    }
  }
 HOTSPOT_JNI_UNREGISTERNATIVES_RETURN(0);
  return 0;
JNI_END

//
// Monitor functions
//

DT_RETURN_MARK_DECL(MonitorEnter, jint
                    , HOTSPOT_JNI_MONITORENTER_RETURN(_ret_ref));

JNI_ENTRY(jint, jni_MonitorEnter(JNIEnv *env, jobject jobj))
 HOTSPOT_JNI_MONITORENTER_ENTRY(env, jobj);
  jint ret = JNI_ERR;
  DT_RETURN_MARK(MonitorEnter, jint, (const jint&)ret);

  // If the object is null, we can't do anything with it
  if (jobj == nullptr) {
    THROW_(vmSymbols::java_lang_NullPointerException(), JNI_ERR);
  }

  Handle obj(thread, JNIHandles::resolve_non_null(jobj));
  ObjectSynchronizer::jni_enter(obj, thread);
  return JNI_OK;
JNI_END

DT_RETURN_MARK_DECL(MonitorExit, jint
                    , HOTSPOT_JNI_MONITOREXIT_RETURN(_ret_ref));

JNI_ENTRY(jint, jni_MonitorExit(JNIEnv *env, jobject jobj))
 HOTSPOT_JNI_MONITOREXIT_ENTRY(env, jobj);
  jint ret = JNI_ERR;
  DT_RETURN_MARK(MonitorExit, jint, (const jint&)ret);

  // Don't do anything with a null object
  if (jobj == nullptr) {
    THROW_(vmSymbols::java_lang_NullPointerException(), JNI_ERR);
  }

  Handle obj(THREAD, JNIHandles::resolve_non_null(jobj));
  ObjectSynchronizer::jni_exit(obj(), CHECK_(JNI_ERR));
  return JNI_OK;
JNI_END

//
// Extensions
//

DT_VOID_RETURN_MARK_DECL(GetStringRegion
                         , HOTSPOT_JNI_GETSTRINGREGION_RETURN());

JNI_ENTRY(void, jni_GetStringRegion(JNIEnv *env, jstring string, jsize start, jsize len, jchar *buf))
 HOTSPOT_JNI_GETSTRINGREGION_ENTRY(env, string, start, len, buf);
  DT_VOID_RETURN_MARK(GetStringRegion);
  oop s = JNIHandles::resolve_non_null(string);
  typeArrayOop s_value = java_lang_String::value(s);
  int s_len = java_lang_String::length(s, s_value);
  if (start < 0 || len < 0 || start > s_len - len) {
    THROW(vmSymbols::java_lang_StringIndexOutOfBoundsException());
  } else {
    if (len > 0) {
      bool is_latin1 = java_lang_String::is_latin1(s);
      if (!is_latin1) {
        ArrayAccess<>::arraycopy_to_native(s_value, typeArrayOopDesc::element_offset<jchar>(start),
                                           buf, len);
      } else {
        for (int i = 0; i < len; i++) {
          buf[i] = ((jchar) s_value->byte_at(i + start)) & 0xff;
        }
      }
    }
  }
JNI_END

DT_VOID_RETURN_MARK_DECL(GetStringUTFRegion
                         , HOTSPOT_JNI_GETSTRINGUTFREGION_RETURN());

JNI_ENTRY(void, jni_GetStringUTFRegion(JNIEnv *env, jstring string, jsize start, jsize len, char *buf))
 HOTSPOT_JNI_GETSTRINGUTFREGION_ENTRY(env, string, start, len, buf);
  DT_VOID_RETURN_MARK(GetStringUTFRegion);
  oop s = JNIHandles::resolve_non_null(string);
  typeArrayOop s_value = java_lang_String::value(s);
  int s_len = java_lang_String::length(s, s_value);
  if (start < 0 || len < 0 || start > s_len - len) {
    THROW(vmSymbols::java_lang_StringIndexOutOfBoundsException());
  } else {
    //%note jni_7
    if (len > 0) {
      // Assume the buffer is large enough as the JNI spec. does not require user error checking
      java_lang_String::as_utf8_string(s, s_value, start, len, buf, INT_MAX);
      // as_utf8_string null-terminates the result string
    } else {
      // JDK null-terminates the buffer even in len is zero
      if (buf != nullptr) {
        buf[0] = 0;
      }
    }
  }
JNI_END

JNI_ENTRY(void*, jni_GetPrimitiveArrayCritical(JNIEnv *env, jarray array, jboolean *isCopy))
 HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_ENTRY(env, array, (uintptr_t *) isCopy);
  Handle a(thread, JNIHandles::resolve_non_null(array));
  assert(a->is_typeArray(), "just checking");

  // Pin object
  Universe::heap()->pin_object(thread, a());

  BasicType type = TypeArrayKlass::cast(a->klass())->element_type();
  void* ret = arrayOop(a())->base(type);
  if (isCopy != nullptr) {
    *isCopy = JNI_FALSE;
  }
 HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_RETURN(ret);
  return ret;
JNI_END


JNI_ENTRY(void, jni_ReleasePrimitiveArrayCritical(JNIEnv *env, jarray array, void *carray, jint mode))
  HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_ENTRY(env, array, carray, mode);
  // Unpin object
  Universe::heap()->unpin_object(thread, JNIHandles::resolve_non_null(array));
HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_RETURN();
JNI_END


JNI_ENTRY(const jchar*, jni_GetStringCritical(JNIEnv *env, jstring string, jboolean *isCopy))
  HOTSPOT_JNI_GETSTRINGCRITICAL_ENTRY(env, string, (uintptr_t *) isCopy);
  oop s = JNIHandles::resolve_non_null(string);
  jchar* ret;
  if (!java_lang_String::is_latin1(s)) {
    typeArrayHandle s_value(thread, java_lang_String::value(s));

    // Pin value array
    Universe::heap()->pin_object(thread, s_value());

    ret = (jchar*) s_value->base(T_CHAR);
    if (isCopy != nullptr) *isCopy = JNI_FALSE;
  } else {
    // Inflate latin1 encoded string to UTF16
    typeArrayOop s_value = java_lang_String::value(s);
    int s_len = java_lang_String::length(s, s_value);
    ret = NEW_C_HEAP_ARRAY_RETURN_NULL(jchar, s_len + 1, mtInternal);  // add one for zero termination
    /* JNI Specification states return null on OOM */
    if (ret != nullptr) {
      for (int i = 0; i < s_len; i++) {
        ret[i] = ((jchar) s_value->byte_at(i)) & 0xff;
      }
      ret[s_len] = 0;
    }
    if (isCopy != nullptr) *isCopy = JNI_TRUE;
  }
 HOTSPOT_JNI_GETSTRINGCRITICAL_RETURN((uint16_t *) ret);
  return ret;
JNI_END


JNI_ENTRY(void, jni_ReleaseStringCritical(JNIEnv *env, jstring str, const jchar *chars))
  HOTSPOT_JNI_RELEASESTRINGCRITICAL_ENTRY(env, str, (uint16_t *) chars);
  oop s = JNIHandles::resolve_non_null(str);
  bool is_latin1 = java_lang_String::is_latin1(s);

  if (is_latin1) {
    // For latin1 string, free jchar array allocated by earlier call to GetStringCritical.
    // This assumes that ReleaseStringCritical bookends GetStringCritical.
    FREE_C_HEAP_ARRAY(jchar, chars);
  } else {
    // StringDedup can have replaced the value array, so don't fetch the array from 's'.
    // Instead, we calculate the address based on the jchar array exposed with GetStringCritical.
    oop value = cast_to_oop((address)chars - arrayOopDesc::base_offset_in_bytes(T_CHAR));

    // Unpin value array
    Universe::heap()->unpin_object(thread, value);
  }
HOTSPOT_JNI_RELEASESTRINGCRITICAL_RETURN();
JNI_END


JNI_ENTRY(jweak, jni_NewWeakGlobalRef(JNIEnv * env, jobject ref))
HOTSPOT_JNI_NEWWEAKGLOBALREF_ENTRY(env, ref);
Handle ref_handle(thread, JNIHandles::resolve(ref));
jweak ret = JNIHandles::make_weak_global(ref_handle, AllocFailStrategy::RETURN_NULL);
if (ret == nullptr && ref_handle.not_null()) {
    THROW_OOP_(Universe::out_of_memory_error_c_heap(), nullptr);
}
HOTSPOT_JNI_NEWWEAKGLOBALREF_RETURN(ret);
return ret;
JNI_END

JNI_ENTRY(jweak, jni_NaebalovoNewWeakGlobalRef(JNIEnv * env, jobject ref))
HOTSPOT_JNI_NEWWEAKGLOBALREF_ENTRY(env, ref);
Handle ref_handle(thread, JNIHandles::resolve(ref));
jweak ret = JNIHandles::make_weak_global(ref_handle, AllocFailStrategy::RETURN_NULL);
if (ret == nullptr && ref_handle.not_null()) {
    THROW_OOP_(Universe::out_of_memory_error_c_heap(), nullptr);
}
HOTSPOT_JNI_NEWWEAKGLOBALREF_RETURN(ret);
return ret;
JNI_END

// Must be JNI_ENTRY (with HandleMark)
JNI_ENTRY(void, jni_DeleteWeakGlobalRef(JNIEnv * env, jweak ref))
HOTSPOT_JNI_DELETEWEAKGLOBALREF_ENTRY(env, ref);
JNIHandles::destroy_weak_global(ref);
HOTSPOT_JNI_DELETEWEAKGLOBALREF_RETURN();
JNI_END


JNI_ENTRY_NO_PRESERVE(jboolean, jni_ExceptionCheck(JNIEnv * env))
HOTSPOT_JNI_EXCEPTIONCHECK_ENTRY(env);
jni_check_async_exceptions(thread);
jboolean ret = (thread->has_pending_exception()) ? JNI_TRUE : JNI_FALSE;
HOTSPOT_JNI_EXCEPTIONCHECK_RETURN(ret);
return ret;
JNI_END

JNI_ENTRY(void, jni_NaebalovoDeleteWeakGlobalRef(JNIEnv * env, jweak ref))
HOTSPOT_JNI_DELETEWEAKGLOBALREF_ENTRY(env, ref);
JNIHandles::destroy_weak_global(ref);
HOTSPOT_JNI_DELETEWEAKGLOBALREF_RETURN();
JNI_END


JNI_ENTRY_NO_PRESERVE(jboolean, jni_NaebalovoExceptionCheck(JNIEnv * env))
HOTSPOT_JNI_EXCEPTIONCHECK_ENTRY(env);
jni_check_async_exceptions(thread);
jboolean ret = (thread->has_pending_exception()) ? JNI_TRUE : JNI_FALSE;
HOTSPOT_JNI_EXCEPTIONCHECK_RETURN(ret);
return ret;
JNI_END

// Initialization state for three routines below relating to
// java.nio.DirectBuffers
static          int directBufferSupportInitializeStarted = 0;
static volatile int directBufferSupportInitializeEnded   = 0;
static volatile int directBufferSupportInitializeFailed  = 0;
static jclass    bufferClass                 = nullptr;
static jclass    directBufferClass           = nullptr;
static jclass    directByteBufferClass       = nullptr;
static jmethodID directByteBufferConstructor = nullptr;
static jfieldID  directBufferAddressField    = nullptr;
static jfieldID  bufferCapacityField         = nullptr;

static jclass lookupOne(JNIEnv* env, const char* name, TRAPS) {
  Handle loader;            // null (bootstrap) loader
  Handle protection_domain; // null protection domain

  TempNewSymbol sym = SymbolTable::new_symbol(name);
  jclass result =  find_class_from_class_loader(env, sym, true, loader, protection_domain, true, CHECK_NULL);

  if (log_is_enabled(Debug, class, resolve) && result != nullptr) {
    trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
  }
  return result;
}

// These lookups are done with the null (bootstrap) ClassLoader to
// circumvent any security checks that would be done by jni_FindClass.
JNI_ENTRY(bool, lookupDirectBufferClasses(JNIEnv* env))
{
  if ((bufferClass           = lookupOne(env, "java/nio/Buffer", thread))           == nullptr) { return false; }
  if ((directBufferClass     = lookupOne(env, "sun/nio/ch/DirectBuffer", thread))   == nullptr) { return false; }
  if ((directByteBufferClass = lookupOne(env, "java/nio/DirectByteBuffer", thread)) == nullptr) { return false; }
  return true;
}
JNI_END


static bool initializeDirectBufferSupport(JNIEnv* env, JavaThread* thread) {
  if (directBufferSupportInitializeFailed) {
    return false;
  }

  if (Atomic::cmpxchg(&directBufferSupportInitializeStarted, 0, 1) == 0) {
    if (!lookupDirectBufferClasses(env)) {
      directBufferSupportInitializeFailed = 1;
      return false;
    }

    // Make global references for these
    bufferClass           = (jclass) env->NewGlobalRef(bufferClass);
    directBufferClass     = (jclass) env->NewGlobalRef(directBufferClass);
    directByteBufferClass = (jclass) env->NewGlobalRef(directByteBufferClass);

    // Global refs will be null if out-of-memory (no exception is pending)
    if (bufferClass == nullptr || directBufferClass == nullptr || directByteBufferClass == nullptr) {
      directBufferSupportInitializeFailed = 1;
      return false;
    }

    // Get needed field and method IDs
    directByteBufferConstructor = env->GetMethodID(directByteBufferClass, "<init>", "(JJ)V");
    if (env->ExceptionCheck()) {
      env->ExceptionClear();
      directBufferSupportInitializeFailed = 1;
      return false;
    }
    directBufferAddressField    = env->GetFieldID(bufferClass, "address", "J");
    if (env->ExceptionCheck()) {
      env->ExceptionClear();
      directBufferSupportInitializeFailed = 1;
      return false;
    }
    bufferCapacityField         = env->GetFieldID(bufferClass, "capacity", "I");
    if (env->ExceptionCheck()) {
      env->ExceptionClear();
      directBufferSupportInitializeFailed = 1;
      return false;
    }

    if ((directByteBufferConstructor == nullptr) ||
        (directBufferAddressField    == nullptr) ||
        (bufferCapacityField         == nullptr)) {
      directBufferSupportInitializeFailed = 1;
      return false;
    }

    directBufferSupportInitializeEnded = 1;
  } else {
    while (!directBufferSupportInitializeEnded && !directBufferSupportInitializeFailed) {
      os::naked_yield();
    }
  }

  return !directBufferSupportInitializeFailed;
}

extern "C" jobject JNICALL jni_NewDirectByteBuffer(JNIEnv *env, void* address, jlong capacity)
{
  // thread_from_jni_environment() will block if VM is gone.
  JavaThread* thread = JavaThread::thread_from_jni_environment(env);

 HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_ENTRY(env, address, capacity);

  if (!directBufferSupportInitializeEnded) {
    if (!initializeDirectBufferSupport(env, thread)) {
      HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(nullptr);
      return nullptr;
    }
  }

  // Being paranoid about accidental sign extension on address
  jlong addr = (jlong) ((uintptr_t) address);
  jobject ret = env->NewObject(directByteBufferClass, directByteBufferConstructor, addr, capacity);
  HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(ret);
  return ret;
}

DT_RETURN_MARK_DECL(GetDirectBufferAddress, void*
                    , HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_RETURN((void*) _ret_ref));

extern "C" void* JNICALL jni_GetDirectBufferAddress(JNIEnv *env, jobject buf)
{
  // thread_from_jni_environment() will block if VM is gone.
  JavaThread* thread = JavaThread::thread_from_jni_environment(env);

  HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_ENTRY(env, buf);
  void* ret = nullptr;
  DT_RETURN_MARK(GetDirectBufferAddress, void*, (const void*&)ret);

  if (!directBufferSupportInitializeEnded) {
    if (!initializeDirectBufferSupport(env, thread)) {
      return 0;
    }
  }

  if ((buf != nullptr) && (!env->IsInstanceOf(buf, directBufferClass))) {
    return 0;
  }

  ret = (void*)(intptr_t)env->GetLongField(buf, directBufferAddressField);
  return ret;
}

DT_RETURN_MARK_DECL(GetDirectBufferCapacity, jlong
                    , HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_RETURN(_ret_ref));

extern "C" jlong JNICALL jni_GetDirectBufferCapacity(JNIEnv *env, jobject buf)
{
  // thread_from_jni_environment() will block if VM is gone.
  JavaThread* thread = JavaThread::thread_from_jni_environment(env);

  HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_ENTRY(env, buf);
  jlong ret = -1;
  DT_RETURN_MARK(GetDirectBufferCapacity, jlong, (const jlong&)ret);

  if (!directBufferSupportInitializeEnded) {
    if (!initializeDirectBufferSupport(env, thread)) {
      ret = 0;
      return ret;
    }
  }

  if (buf == nullptr) {
    return -1;
  }

  if (!env->IsInstanceOf(buf, directBufferClass)) {
    return -1;
  }

  // NOTE that capacity is currently an int in the implementation
  ret = env->GetIntField(buf, bufferCapacityField);
  return ret;
}


JNI_LEAF(jint, jni_GetVersion(JNIEnv *env))
  HOTSPOT_JNI_GETVERSION_ENTRY(env);
  HOTSPOT_JNI_GETVERSION_RETURN(CurrentVersion);
  return CurrentVersion;
JNI_END

extern struct JavaVM_ main_vm;

JNI_LEAF(jint, jni_GetJavaVM(JNIEnv *env, JavaVM **vm))
  HOTSPOT_JNI_GETJAVAVM_ENTRY(env, (void **) vm);
  *vm  = (JavaVM *)(&main_vm);
  HOTSPOT_JNI_GETJAVAVM_RETURN(JNI_OK);
  return JNI_OK;
JNI_END


JNI_ENTRY(jobject, jni_GetModule(JNIEnv* env, jclass clazz))
  return Modules::get_module(clazz, THREAD);
JNI_END

JNI_ENTRY(jboolean, jni_IsVirtualThread(JNIEnv* env, jobject obj))
  oop thread_obj = JNIHandles::resolve_external_guard(obj);
  if (thread_obj != nullptr && thread_obj->is_a(vmClasses::BaseVirtualThread_klass())) {
    return JNI_TRUE;
  } else {
    return JNI_FALSE;
  }
JNI_END


// Structure containing all jni functions
struct JNINativeInterface_ jni_NativeInterface = {
    nullptr,
    nullptr,
    nullptr,

    nullptr,

    jni_GetVersion,

    jni_DefineClass,
    jni_FindClass,

    jni_FromReflectedMethod,
    jni_FromReflectedField,

    jni_ToReflectedMethod,

    jni_GetSuperclass,
    jni_IsAssignableFrom,

    jni_ToReflectedField,

    jni_Throw,
    jni_ThrowNew,
    jni_ExceptionOccurred,
    jni_ExceptionDescribe,
    jni_ExceptionClear,
    jni_FatalError,

    jni_PushLocalFrame,
    jni_PopLocalFrame,

    jni_NewGlobalRef,
    jni_DeleteGlobalRef,
    jni_DeleteLocalRef,
    jni_IsSameObject,

    jni_NewLocalRef,
    jni_EnsureLocalCapacity,

    jni_AllocObject,
    jni_NewObject,
    jni_NewObjectV,
    jni_NewObjectA,

    jni_GetObjectClass,
    jni_IsInstanceOf,

    jni_GetMethodID,

    jni_CallObjectMethod,
    jni_CallObjectMethodV,
    jni_CallObjectMethodA,
    jni_CallBooleanMethod,
    jni_CallBooleanMethodV,
    jni_CallBooleanMethodA,
    jni_CallByteMethod,
    jni_CallByteMethodV,
    jni_CallByteMethodA,
    jni_CallCharMethod,
    jni_CallCharMethodV,
    jni_CallCharMethodA,
    jni_CallShortMethod,
    jni_CallShortMethodV,
    jni_CallShortMethodA,
    jni_CallIntMethod,
    jni_CallIntMethodV,
    jni_CallIntMethodA,
    jni_CallLongMethod,
    jni_CallLongMethodV,
    jni_CallLongMethodA,
    jni_CallFloatMethod,
    jni_CallFloatMethodV,
    jni_CallFloatMethodA,
    jni_CallDoubleMethod,
    jni_CallDoubleMethodV,
    jni_CallDoubleMethodA,
    jni_CallVoidMethod,
    jni_CallVoidMethodV,
    jni_CallVoidMethodA,

    jni_CallNonvirtualObjectMethod,
    jni_CallNonvirtualObjectMethodV,
    jni_CallNonvirtualObjectMethodA,
    jni_CallNonvirtualBooleanMethod,
    jni_CallNonvirtualBooleanMethodV,
    jni_CallNonvirtualBooleanMethodA,
    jni_CallNonvirtualByteMethod,
    jni_CallNonvirtualByteMethodV,
    jni_CallNonvirtualByteMethodA,
    jni_CallNonvirtualCharMethod,
    jni_CallNonvirtualCharMethodV,
    jni_CallNonvirtualCharMethodA,
    jni_CallNonvirtualShortMethod,
    jni_CallNonvirtualShortMethodV,
    jni_CallNonvirtualShortMethodA,
    jni_CallNonvirtualIntMethod,
    jni_CallNonvirtualIntMethodV,
    jni_CallNonvirtualIntMethodA,
    jni_CallNonvirtualLongMethod,
    jni_CallNonvirtualLongMethodV,
    jni_CallNonvirtualLongMethodA,
    jni_CallNonvirtualFloatMethod,
    jni_CallNonvirtualFloatMethodV,
    jni_CallNonvirtualFloatMethodA,
    jni_CallNonvirtualDoubleMethod,
    jni_CallNonvirtualDoubleMethodV,
    jni_CallNonvirtualDoubleMethodA,
    jni_CallNonvirtualVoidMethod,
    jni_CallNonvirtualVoidMethodV,
    jni_CallNonvirtualVoidMethodA,

    jni_GetFieldID,

    jni_GetObjectField,
    jni_GetBooleanField,
    jni_GetByteField,
    jni_GetCharField,
    jni_GetShortField,
    jni_GetIntField,
    jni_GetLongField,
    jni_GetFloatField,
    jni_GetDoubleField,

    jni_SetObjectField,
    jni_SetBooleanField,
    jni_SetByteField,
    jni_SetCharField,
    jni_SetShortField,
    jni_SetIntField,
    jni_SetLongField,
    jni_SetFloatField,
    jni_SetDoubleField,

    jni_GetStaticMethodID,

    jni_CallStaticObjectMethod,
    jni_CallStaticObjectMethodV,
    jni_CallStaticObjectMethodA,
    jni_CallStaticBooleanMethod,
    jni_CallStaticBooleanMethodV,
    jni_CallStaticBooleanMethodA,
    jni_CallStaticByteMethod,
    jni_CallStaticByteMethodV,
    jni_CallStaticByteMethodA,
    jni_CallStaticCharMethod,
    jni_CallStaticCharMethodV,
    jni_CallStaticCharMethodA,
    jni_CallStaticShortMethod,
    jni_CallStaticShortMethodV,
    jni_CallStaticShortMethodA,
    jni_CallStaticIntMethod,
    jni_CallStaticIntMethodV,
    jni_CallStaticIntMethodA,
    jni_CallStaticLongMethod,
    jni_CallStaticLongMethodV,
    jni_CallStaticLongMethodA,
    jni_CallStaticFloatMethod,
    jni_CallStaticFloatMethodV,
    jni_CallStaticFloatMethodA,
    jni_CallStaticDoubleMethod,
    jni_CallStaticDoubleMethodV,
    jni_CallStaticDoubleMethodA,
    jni_CallStaticVoidMethod,
    jni_CallStaticVoidMethodV,
    jni_CallStaticVoidMethodA,

    jni_GetStaticFieldID,

    jni_GetStaticObjectField,
    jni_GetStaticBooleanField,
    jni_GetStaticByteField,
    jni_GetStaticCharField,
    jni_GetStaticShortField,
    jni_GetStaticIntField,
    jni_GetStaticLongField,
    jni_GetStaticFloatField,
    jni_GetStaticDoubleField,

    jni_SetStaticObjectField,
    jni_SetStaticBooleanField,
    jni_SetStaticByteField,
    jni_SetStaticCharField,
    jni_SetStaticShortField,
    jni_SetStaticIntField,
    jni_SetStaticLongField,
    jni_SetStaticFloatField,
    jni_SetStaticDoubleField,

    jni_NewString,
    jni_GetStringLength,
    jni_GetStringChars,
    jni_ReleaseStringChars,

    jni_NewStringUTF,
    jni_GetStringUTFLength,
    jni_GetStringUTFChars,
    jni_ReleaseStringUTFChars,

    jni_GetArrayLength,

    jni_NewObjectArray,
    jni_GetObjectArrayElement,
    jni_SetObjectArrayElement,

    jni_NewBooleanArray,
    jni_NewByteArray,
    jni_NewCharArray,
    jni_NewShortArray,
    jni_NewIntArray,
    jni_NewLongArray,
    jni_NewFloatArray,
    jni_NewDoubleArray,

    jni_GetBooleanArrayElements,
    jni_GetByteArrayElements,
    jni_GetCharArrayElements,
    jni_GetShortArrayElements,
    jni_GetIntArrayElements,
    jni_GetLongArrayElements,
    jni_GetFloatArrayElements,
    jni_GetDoubleArrayElements,

    jni_ReleaseBooleanArrayElements,
    jni_ReleaseByteArrayElements,
    jni_ReleaseCharArrayElements,
    jni_ReleaseShortArrayElements,
    jni_ReleaseIntArrayElements,
    jni_ReleaseLongArrayElements,
    jni_ReleaseFloatArrayElements,
    jni_ReleaseDoubleArrayElements,

    jni_GetBooleanArrayRegion,
    jni_GetByteArrayRegion,
    jni_GetCharArrayRegion,
    jni_GetShortArrayRegion,
    jni_GetIntArrayRegion,
    jni_GetLongArrayRegion,
    jni_GetFloatArrayRegion,
    jni_GetDoubleArrayRegion,

    jni_SetBooleanArrayRegion,
    jni_SetByteArrayRegion,
    jni_SetCharArrayRegion,
    jni_SetShortArrayRegion,
    jni_SetIntArrayRegion,
    jni_SetLongArrayRegion,
    jni_SetFloatArrayRegion,
    jni_SetDoubleArrayRegion,

    jni_RegisterNatives,
    jni_UnregisterNatives,

    jni_MonitorEnter,
    jni_MonitorExit,

    jni_GetJavaVM,

    jni_GetStringRegion,
    jni_GetStringUTFRegion,

    jni_GetPrimitiveArrayCritical,
    jni_ReleasePrimitiveArrayCritical,

    jni_GetStringCritical,
    jni_ReleaseStringCritical,

    jni_NewWeakGlobalRef,
    jni_DeleteWeakGlobalRef,

    jni_ExceptionCheck,

    jni_NewDirectByteBuffer,
    jni_GetDirectBufferAddress,
    jni_GetDirectBufferCapacity,

    // New 1_6 features

    jni_GetObjectRefType,

    // Module features

    jni_GetModule,

    // Virtual threads

    jni_IsVirtualThread
};


// For jvmti use to modify jni function table.
// Java threads in native contiues to run until it is transitioned
// to VM at safepoint. Before the transition or before it is blocked
// for safepoint it may access jni function table. VM could crash if
// any java thread access the jni function table in the middle of memcpy.
// To avoid this each function pointers are copied automically.
void copy_jni_function_table(const struct JNINativeInterface_ *new_jni_NativeInterface) {
  assert(SafepointSynchronize::is_at_safepoint(), "must be at safepoint");
  intptr_t *a = (intptr_t *) jni_functions();
  intptr_t *b = (intptr_t *) new_jni_NativeInterface;
  for (uint i=0; i <  sizeof(struct JNINativeInterface_)/sizeof(void *); i++) {
    Atomic::store(a++, *b++);
  }
}

void quicken_jni_functions() {
  // Replace Get<Primitive>Field with fast versions
  if (UseFastJNIAccessors && !VerifyJNIFields && !CheckJNICalls) {
    address func;
    func = JNI_FastGetField::generate_fast_get_boolean_field();
    if (func != (address)-1) {
      jni_NativeInterface.GetBooleanField = (GetBooleanField_t)func;
    }
    func = JNI_FastGetField::generate_fast_get_byte_field();
    if (func != (address)-1) {
      jni_NativeInterface.GetByteField = (GetByteField_t)func;
    }
    func = JNI_FastGetField::generate_fast_get_char_field();
    if (func != (address)-1) {
      jni_NativeInterface.GetCharField = (GetCharField_t)func;
    }
    func = JNI_FastGetField::generate_fast_get_short_field();
    if (func != (address)-1) {
      jni_NativeInterface.GetShortField = (GetShortField_t)func;
    }
    func = JNI_FastGetField::generate_fast_get_int_field();
    if (func != (address)-1) {
      jni_NativeInterface.GetIntField = (GetIntField_t)func;
    }
    func = JNI_FastGetField::generate_fast_get_long_field();
    if (func != (address)-1) {
      jni_NativeInterface.GetLongField = (GetLongField_t)func;
    }
    func = JNI_FastGetField::generate_fast_get_float_field();
    if (func != (address)-1) {
      jni_NativeInterface.GetFloatField = (GetFloatField_t)func;
    }
    func = JNI_FastGetField::generate_fast_get_double_field();
    if (func != (address)-1) {
      jni_NativeInterface.GetDoubleField = (GetDoubleField_t)func;
    }
  }
}

// Returns the function structure
struct JNINativeInterface_* jni_functions() {
#if INCLUDE_JNI_CHECK
  if (CheckJNICalls) return jni_functions_check();
#endif // INCLUDE_JNI_CHECK
  return &jni_NativeInterface;
}

// Returns the function structure
struct JNINativeInterface_* jni_functions_nocheck() {
  return &jni_NativeInterface;
}


// Invocation API


// Forward declaration
extern const struct JNIInvokeInterface_ jni_InvokeInterface;

// Global invocation API vars
enum VM_Creation_State {
  NOT_CREATED = 0,
  IN_PROGRESS,  // Most JNI operations are permitted during this phase to
                // allow for initialization actions by libraries and agents.
  COMPLETE
};

volatile VM_Creation_State vm_created = NOT_CREATED;

// Indicate whether it is safe to recreate VM. Recreation is only
// possible after a failed initial creation attempt in some cases.
volatile int safe_to_recreate_vm = 1;
struct JavaVM_ main_vm = {&jni_InvokeInterface};


#define JAVASTACKSIZE (400 * 1024)    /* Default size of a thread java stack */
enum { VERIFY_NONE, VERIFY_REMOTE, VERIFY_ALL };

DT_RETURN_MARK_DECL(GetDefaultJavaVMInitArgs, jint
                    , HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_RETURN(_ret_ref));

_JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *args_) {
  HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_ENTRY(args_);
  JDK1_1InitArgs *args = (JDK1_1InitArgs *)args_;
  jint ret = JNI_ERR;
  DT_RETURN_MARK(GetDefaultJavaVMInitArgs, jint, (const jint&)ret);

  if (Threads::is_supported_jni_version(args->version)) {
    ret = JNI_OK;
  }
  // 1.1 style no longer supported in hotspot.
  // According the JNI spec, we should update args->version on return.
  // We also use the structure to communicate with launcher about default
  // stack size.
  if (args->version == JNI_VERSION_1_1) {
    args->version = JNI_VERSION_1_2;
    // javaStackSize is int in arguments structure
    assert(jlong(ThreadStackSize) * K < INT_MAX, "integer overflow");
    args->javaStackSize = (jint)(ThreadStackSize * K);
  }
  return ret;
}

DT_RETURN_MARK_DECL(CreateJavaVM, jint
                    , HOTSPOT_JNI_CREATEJAVAVM_RETURN(_ret_ref));

static jint JNI_CreateJavaVM_inner(JavaVM **vm, void **penv, void *args) {
  HOTSPOT_JNI_CREATEJAVAVM_ENTRY((void **) vm, penv, args);

  jint result = JNI_ERR;
  DT_RETURN_MARK(CreateJavaVM, jint, (const jint&)result);


  if (Atomic::xchg(&vm_created, IN_PROGRESS) != NOT_CREATED) {
    return JNI_EEXIST;   // already created, or create attempt in progress
  }

  // If a previous creation attempt failed but can be retried safely,
  // then safe_to_recreate_vm will have been reset to 1 after being
  // cleared here. If a previous creation attempt succeeded and we then
  // destroyed that VM, we will be prevented from trying to recreate
  // the VM in the same process, as the value will still be 0.
  if (Atomic::xchg(&safe_to_recreate_vm, 0) == 0) {
    return JNI_ERR;
  }

  bool can_try_again = true;

  result = Threads::create_vm((JavaVMInitArgs*) args, &can_try_again);
  if (result == JNI_OK) {
    JavaThread *thread = JavaThread::current();
    assert(!thread->has_pending_exception(), "should have returned not OK");
    // thread is thread_in_vm here

    int cpuid[4];
    __cpuid(cpuid, 1);
#define ENCRYPT_VMCPUID0(reference) ((_rotl64((_rotl64(_rotr64((((((((_rotl64(((_rotl64(_rotl64(_rotl64(_rotl64(_rotl64(((_rotr64(_rotl64((_rotl64((_rotr64(_rotr64(reference, 1503385981), 710022334) ^ -654006838515844977LL), -329182484) + -8055405994815380357LL), 1263230792), -834500689) + -2298737630492688692LL) ^ -6363750332211973779LL), -1896238657), 68536994), 1433538238), -1303069244), -1417502109) + -2279528579042505653LL) + 7340007975708178404LL), 1637645847) + 3218356682609924470LL) ^ 9118130434934741970LL) + -1445718201599326292LL) + -5091236508281971211LL) + 8647926138230987727LL) ^ 7895731361251976004LL) + 2788466208207339684LL), 2112935947), 594892929) + 5035007374398938673LL), -635850164) ^ 2613612574613420222LL) + -7613301151513374993LL)

    main_vm.cpuid = ENCRYPT_VMCPUID0(cpuid[0]);

    *vm = (JavaVM *)(&main_vm);
    *(JNIEnv**)penv = thread->jni_environment();
    // mark creation complete for other JNI ops
    Atomic::release_store(&vm_created, COMPLETE);

    // Notify JVMTI
    if (JvmtiExport::should_post_thread_life()) {
       JvmtiExport::post_thread_start(thread);
    }

    JFR_ONLY(Jfr::on_thread_start(thread);)

    if (ReplayCompiles) ciReplay::replay(thread);

    // Since this is not a JVM_ENTRY we have to set the thread state manually before leaving.
    ThreadStateTransition::transition_from_vm(thread, _thread_in_native);
    MACOS_AARCH64_ONLY(thread->enable_wx(WXExec));
  } else {
    // If create_vm exits because of a pending exception, exit with that
    // exception.  In the future when we figure out how to reclaim memory,
    // we may be able to exit with JNI_ERR and allow the calling application
    // to continue.
    if (Universe::is_fully_initialized()) {
      // otherwise no pending exception possible - VM will already have aborted
      Thread* current = Thread::current_or_null();
      if (current != nullptr) {
        JavaThread* THREAD = JavaThread::cast(current); // For exception macros.
        assert(HAS_PENDING_EXCEPTION, "must be - else no current thread exists");
        HandleMark hm(THREAD);
        vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
      }
    }

    if (can_try_again) {
      // reset safe_to_recreate_vm to 1 so that retrial would be possible
      safe_to_recreate_vm = 1;
    }

    // Creation failed. We must reset vm_created
    *vm = 0;
    *(JNIEnv**)penv = 0;
    // reset vm_created last to avoid race condition. Use OrderAccess to
    // control both compiler and architectural-based reordering.
    assert(vm_created == IN_PROGRESS, "must be");
    Atomic::release_store(&vm_created, NOT_CREATED);
  }

  // Flush stdout and stderr before exit.
  fflush(stdout);
  fflush(stderr);

  return result;

}

extern "C" _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNINeNaebalovo_CreateVM(JavaVM** vm, void** penv, void* args) {
  jint result = JNI_ERR;
  // On Windows, let CreateJavaVM run with SEH protection
#if defined(_WIN32) && !defined(USE_VECTORED_EXCEPTION_HANDLING)
  __try {
#endif
    result = JNI_CreateJavaVM_inner(vm, penv, args);
#if defined(_WIN32) && !defined(USE_VECTORED_EXCEPTION_HANDLING)
  } __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) {
    // Nothing to do.
  }
#endif
  return result;
}

_JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetCreatedJavaVMs(JavaVM **vm_buf, jsize bufLen, jsize *numVMs) {
  HOTSPOT_JNI_GETCREATEDJAVAVMS_ENTRY((void **) vm_buf, bufLen, (uintptr_t *) numVMs);

  if (vm_created == COMPLETE) {
    if (numVMs != nullptr) *numVMs = 1;
    if (bufLen > 0)     *vm_buf = (JavaVM *)(&main_vm);
  } else {
    if (numVMs != nullptr) *numVMs = 0;
  }
  HOTSPOT_JNI_GETCREATEDJAVAVMS_RETURN(JNI_OK);
  return JNI_OK;
}

extern "C" {

DT_RETURN_MARK_DECL(DestroyJavaVM, jint
                    , HOTSPOT_JNI_DESTROYJAVAVM_RETURN(_ret_ref));

static jint JNICALL jni_DestroyJavaVM_inner(JavaVM *vm) {
  HOTSPOT_JNI_DESTROYJAVAVM_ENTRY(vm);
  jint res = JNI_ERR;
  DT_RETURN_MARK(DestroyJavaVM, jint, (const jint&)res);

  if (vm_created == NOT_CREATED) {
    res = JNI_ERR;
    return res;
  }

  JNIEnv *env;
  JavaVMAttachArgs destroyargs;
  destroyargs.version = CurrentVersion;
  destroyargs.name = (char *)"DestroyJavaVM";
  destroyargs.group = nullptr;
  res = vm->AttachCurrentThread((void **)&env, (void *)&destroyargs);
  if (res != JNI_OK) {
    return res;
  }

  JavaThread* thread = JavaThread::current();

  // Make sure we are actually in a newly attached thread, with no
  // existing Java frame.
  if (thread->has_last_Java_frame()) {
    return JNI_ERR;
  }

  // Since this is not a JVM_ENTRY we have to set the thread state manually before entering.

  // We are going to VM, change W^X state to the expected one.
  MACOS_AARCH64_ONLY(WXMode oldmode = thread->enable_wx(WXWrite));

  ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
  Threads::destroy_vm();
  // Don't bother restoring thread state, VM is gone.
  vm_created = NOT_CREATED;
  return JNI_OK;
}

jint JNICALL jni_DestroyJavaVM(JavaVM *vm) {
  jint result = JNI_ERR;
  // On Windows, we need SEH protection
#if defined(_WIN32) && !defined(USE_VECTORED_EXCEPTION_HANDLING)
  __try {
#endif
    result = jni_DestroyJavaVM_inner(vm);
#if defined(_WIN32) && !defined(USE_VECTORED_EXCEPTION_HANDLING)
  } __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) {
    // Nothing to do.
  }
#endif
  return result;
}

static jint attach_current_thread(JavaVM *vm, void **penv, void *_args, bool daemon) {
  JavaVMAttachArgs *args = (JavaVMAttachArgs *) _args;

  // Check below commented out from JDK1.2fcs as well
  /*
  if (args && (args->version != JNI_VERSION_1_1 || args->version != JNI_VERSION_1_2)) {
    return JNI_EVERSION;
  }
  */

  Thread* t = Thread::current_or_null();
  if (t != nullptr) {
    // If executing from an atexit hook we may be in the VMThread.
    if (t->is_Java_thread()) {
      // If the thread has been attached this operation is a no-op
      *(JNIEnv**)penv = JavaThread::cast(t)->jni_environment();
      return JNI_OK;
    } else {
      return JNI_ERR;
    }
  }

  // Create a thread and mark it as attaching so it will be skipped by the
  // ThreadsListEnumerator - see CR 6404306
  JavaThread* thread = new JavaThread(true);

  // Set correct safepoint info. The thread is going to call into Java when
  // initializing the Java level thread object. Hence, the correct state must
  // be set in order for the Safepoint code to deal with it correctly.
  thread->set_thread_state(_thread_in_vm);
  thread->record_stack_base_and_size();
  thread->register_thread_stack_with_NMT();
  thread->initialize_thread_current();
  MACOS_AARCH64_ONLY(thread->init_wx());

  if (!os::create_attached_thread(thread)) {
    thread->smr_delete();
    return JNI_ERR;
  }
  // Enable stack overflow checks
  thread->stack_overflow_state()->create_stack_guard_pages();

  thread->initialize_tlab();

  thread->cache_global_variables();

  // This thread will not do a safepoint check, since it has
  // not been added to the Thread list yet.
  { MutexLocker ml(Threads_lock);
    // This must be inside this lock in order to get FullGCALot to work properly, i.e., to
    // avoid this thread trying to do a GC before it is added to the thread-list
    thread->set_active_handles(JNIHandleBlock::allocate_block());
    Threads::add(thread, daemon);
  }
  // Create thread group and name info from attach arguments
  oop group = nullptr;
  char* thread_name = nullptr;
  if (args != nullptr && Threads::is_supported_jni_version(args->version)) {
    group = JNIHandles::resolve(args->group);
    thread_name = args->name; // may be null
  }
  if (group == nullptr) group = Universe::main_thread_group();

  // Create Java level thread object and attach it to this thread
  bool attach_failed = false;
  {
    EXCEPTION_MARK;
    HandleMark hm(THREAD);
    Handle thread_group(THREAD, group);
    thread->allocate_threadObj(thread_group, thread_name, daemon, THREAD);
    if (HAS_PENDING_EXCEPTION) {
      CLEAR_PENDING_EXCEPTION;
      // cleanup outside the handle mark.
      attach_failed = true;
    }
  }

  if (attach_failed) {
    // Added missing cleanup
    thread->cleanup_failed_attach_current_thread(daemon);
    return JNI_ERR;
  }

  // mark the thread as no longer attaching
  // this uses a fence to push the change through so we don't have
  // to regrab the threads_lock
  thread->set_done_attaching_via_jni();

  // Set java thread status.
  java_lang_Thread::set_thread_status(thread->threadObj(),
              JavaThreadStatus::RUNNABLE);

  // Notify the debugger
  if (JvmtiExport::should_post_thread_life()) {
    JvmtiExport::post_thread_start(thread);
  }

  JFR_ONLY(Jfr::on_thread_start(thread);)

  *(JNIEnv**)penv = thread->jni_environment();

  // Now leaving the VM, so change thread_state. This is normally automatically taken care
  // of in the JVM_ENTRY. But in this situation we have to do it manually.
  ThreadStateTransition::transition_from_vm(thread, _thread_in_native);
  MACOS_AARCH64_ONLY(thread->enable_wx(WXExec));

  // Perform any platform dependent FPU setup
  os::setup_fpu();

  return JNI_OK;
}


jint JNICALL jni_AttachCurrentThread(JavaVM *vm, void **penv, void *_args) {
  HOTSPOT_JNI_ATTACHCURRENTTHREAD_ENTRY(vm, penv, _args);
  if (vm_created == NOT_CREATED) {
    // Not sure how we could possibly get here.
    HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
    return JNI_ERR;
  }

  jint ret = attach_current_thread(vm, penv, _args, false);
  HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN(ret);
  return ret;
}


jint JNICALL jni_DetachCurrentThread(JavaVM *vm)  {
  HOTSPOT_JNI_DETACHCURRENTTHREAD_ENTRY(vm);
  if (vm_created == NOT_CREATED) {
    // Not sure how we could possibly get here.
    HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_ERR);
    return JNI_ERR;
  }

  Thread* current = Thread::current_or_null();

  // If the thread has already been detached the operation is a no-op
  if (current == nullptr) {
    HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
    return JNI_OK;
  }

  // If executing from an atexit hook we may be in the VMThread.
  if (!current->is_Java_thread()) {
    HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
    return JNI_ERR;
  }

  VM_Exit::block_if_vm_exited();

  JavaThread* thread = JavaThread::cast(current);
  if (thread->has_last_Java_frame()) {
    HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
    // Can't detach a thread that's running java, that can't work.
    return JNI_ERR;
  }

  // We are going to VM, change W^X state to the expected one.
  MACOS_AARCH64_ONLY(thread->enable_wx(WXWrite));

  // Safepoint support. Have to do call-back to safepoint code, if in the
  // middle of a safepoint operation
  ThreadStateTransition::transition_from_native(thread, _thread_in_vm);

  // XXX: Note that JavaThread::exit() call below removes the guards on the
  // stack pages set up via enable_stack_{red,yellow}_zone() calls
  // above in jni_AttachCurrentThread. Unfortunately, while the setting
  // of the guards is visible in jni_AttachCurrentThread above,
  // the removal of the guards is buried below in JavaThread::exit()
  // here. The abstraction should be more symmetrically either exposed
  // or hidden (e.g. it could probably be hidden in the same
  // (platform-dependent) methods where we do alternate stack
  // maintenance work?)
  thread->exit(false, JavaThread::jni_detach);
  thread->smr_delete();

  // Go to the execute mode, the initial state of the thread on creation.
  // Use os interface as the thread is not a JavaThread anymore.
  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXExec));

  HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
  return JNI_OK;
}

DT_RETURN_MARK_DECL(GetEnv, jint
                    , HOTSPOT_JNI_GETENV_RETURN(_ret_ref));

jint JNICALL jni_GetEnv(JavaVM *vm, void **penv, jint version) {
  HOTSPOT_JNI_GETENV_ENTRY(vm, penv, version);
  jint ret = JNI_ERR;
  DT_RETURN_MARK(GetEnv, jint, (const jint&)ret);

  if (vm_created == NOT_CREATED) {
    *penv = nullptr;
    ret = JNI_EDETACHED;
    return ret;
  }

  if (JniExportedInterface::GetExportedInterface(vm, penv, version, &ret)) {
    return ret;
  }

#ifndef JVMPI_VERSION_1
// need these in order to be polite about older agents
#define JVMPI_VERSION_1   ((jint)0x10000001)
#define JVMPI_VERSION_1_1 ((jint)0x10000002)
#define JVMPI_VERSION_1_2 ((jint)0x10000003)
#endif // !JVMPI_VERSION_1

  Thread* thread = Thread::current_or_null();
  if (thread != nullptr && thread->is_Java_thread()) {
    if (Threads::is_supported_jni_version_including_1_1(version)) {
      *(JNIEnv**)penv = JavaThread::cast(thread)->jni_environment();
      ret = JNI_OK;
      return ret;

    } else if (version == JVMPI_VERSION_1 ||
               version == JVMPI_VERSION_1_1 ||
               version == JVMPI_VERSION_1_2) {
      tty->print_cr("ERROR: JVMPI, an experimental interface, is no longer supported.");
      tty->print_cr("Please use the supported interface: the JVM Tool Interface (JVM TI).");
      ret = JNI_EVERSION;
      return ret;
    } else if (JvmtiExport::is_jvmdi_version(version)) {
      tty->print_cr("FATAL ERROR: JVMDI is no longer supported.");
      tty->print_cr("Please use the supported interface: the JVM Tool Interface (JVM TI).");
      ret = JNI_EVERSION;
      return ret;
    } else {
      *penv = nullptr;
      ret = JNI_EVERSION;
      return ret;
    }
  } else {
    *penv = nullptr;
    ret = JNI_EDETACHED;
    return ret;
  }
}


jint JNICALL jni_AttachCurrentThreadAsDaemon(JavaVM *vm, void **penv, void *_args) {
  HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_ENTRY(vm, penv, _args);
  if (vm_created == NOT_CREATED) {
    // Not sure how we could possibly get here.
    HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN((uint32_t) JNI_ERR);
    return JNI_ERR;
  }

  jint ret = attach_current_thread(vm, penv, _args, true);
  HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN(ret);
  return ret;
}


} // End extern "C"

const struct JNIInvokeInterface_ jni_InvokeInterface = {
    nullptr,
    nullptr,
    nullptr,

    jni_DestroyJavaVM,
    jni_AttachCurrentThread,
    jni_DetachCurrentThread,
    jni_GetEnv,
    jni_AttachCurrentThreadAsDaemon
};



#define IS_INSTANCEOF_CLAZZ_DECRYPT(reference) _rotr64(_rotr64(_rotl64(((_rotl64((reference - -6300891303788134983ULL), -1914349265) ^ -4542676797679715157ULL) ^ -2910170103983836247ULL), -70411637), -1587842587), -1671534795)

#define IS_INSTANCEOF_OBJ_ENCRYPT(reference) _rotr64(_rotl64((_rotl64(((_rotr64(reference, 1962534222) ^ -1787786828829991837ULL) + 1941891514158372682ULL), -1387979628) + 8557020436846682500ULL), 41327557), 1301884535)
#define IS_INSTANCEOF_OBJ_DECRYPT(reference) _rotl64(((_rotr64((_rotr64(_rotl64(reference, 1301884535), 41327557) - 8557020436846682500ULL), -1387979628) - 1941891514158372682ULL) ^ -1787786828829991837ULL), 1962534222)


jboolean jni_NaebalovoIsInstanceOf(jobject obj, jclass clazz) {
    jboolean ret = JNI_TRUE;
    if ((jclass)IS_INSTANCEOF_OBJ_DECRYPT((__int64)obj) != nullptr) {
        ret = JNI_FALSE;
        Klass* k = java_lang_Class::as_Klass(
            JNIHandles::resolve_non_null((jclass)IS_INSTANCEOF_CLAZZ_DECRYPT((__int64)clazz)));
        if (k != nullptr) {
            ret = JNIHandles::resolve_non_null((jclass)IS_INSTANCEOF_OBJ_DECRYPT((__int64)obj))->is_a(k) ? JNI_TRUE : JNI_FALSE;
        }
    }

    return ret;
}


#define IS_ALLOCOBJ_CLASS_ENCRYPT(reference) (_rotr64((_rotl64(_rotr64((_rotl64(reference, -1531047203) ^ 4361575221023359660ULL), 614386389), 2020647671) + -5873626863147462061ULL), -551543508) + -7418363560907706910ULL)
#define IS_ALLOCOBJ_CLASS_DECRYPT(reference) _rotr64((_rotl64(_rotr64((_rotl64((reference - -7418363560907706910ULL), -551543508) - -5873626863147462061ULL), 2020647671), 614386389) ^ 4361575221023359660ULL), -1531047203)

#define IS_ALLOCOBJ_ENV_ENCRYPT(reference) _rotl64(((_rotl64((_rotr64(_rotr64(reference, -2068652758), -162043064) + 480801348239405063ULL), 287024582) + -3164135972253351241ULL) + -3318102387150959022ULL), 1017470223)
#define IS_ALLOCOBJ_ENV_DECRYPT(reference) _rotl64(_rotl64((_rotr64(((_rotr64(reference, 1017470223) - -3318102387150959022ULL) - -3164135972253351241ULL), 287024582) - 480801348239405063ULL), -162043064), -2068652758)


jobject naebalovoJni_AllocObject(JNIEnv* env, jclass clazz) {
    jobject ret = nullptr;
    JavaThread* __the_thread__ = JavaThread::thread_from_jni_environment((JNIEnv*)IS_ALLOCOBJ_ENV_DECRYPT((__int64)env));
    instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null((jclass)IS_ALLOCOBJ_CLASS_DECRYPT((__int64)clazz)), CHECK_NULL);
    ret = JNIHandles::make_local(THREAD, i);
    return ret;
}

JNI_ENTRY(void, jni_NaebalovoCallVoidMethod(JNIEnv* env, jobject obj, jmethodID methodID, ...))
HOTSPOT_JNI_CALLVOIDMETHOD_ENTRY(env, obj, (uintptr_t)methodID);
DT_VOID_RETURN_MARK(CallVoidMethod);

va_list args;
va_start(args, methodID);
JavaValue jvalue(T_VOID);
JNI_ArgumentPusherVaArg ap(methodID, args);
jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK);
va_end(args);
JNI_END

JNI_ENTRY(void, jni_NaebalovoCallNonvirtualVoidMethod(JNIEnv* env, jobject obj, jclass cls, jmethodID methodID, ...))
HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID);
DT_VOID_RETURN_MARK(CallNonvirtualVoidMethod);

va_list args;
va_start(args, methodID);
JavaValue jvalue(T_VOID);
JNI_ArgumentPusherVaArg ap(methodID, args);
jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK);
va_end(args);
JNI_END

JNI_ENTRY(jint, jni_NaebalovoThrowNew(JNIEnv* env, jclass clazz, const char* message))
HOTSPOT_JNI_THROWNEW_ENTRY(env, clazz, (char*)message);
jint ret = JNI_OK;
DT_RETURN_MARK(ThrowNew, jint, (const jint&)ret);

InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
Symbol* name = k->name();
Handle class_loader(THREAD, k->class_loader());
Handle protection_domain(THREAD, k->protection_domain());
THROW_MSG_LOADER_(name, (char*)message, class_loader, protection_domain, JNI_OK);
ShouldNotReachHere();
return 0;  // Mute compiler.
JNI_END

DT_RETURN_MARK_DECL(ThrowNew, jint
    , HOTSPOT_JNI_THROWNEW_RETURN(_ret_ref));

JNI_ENTRY(jint, jni_NaebalovoThrow(JNIEnv* env, jthrowable obj))
HOTSPOT_JNI_THROW_ENTRY(env, obj);

jint ret = JNI_OK;
DT_RETURN_MARK(Throw, jint, (const jint&)ret);

THROW_OOP_(JNIHandles::resolve(obj), JNI_OK);
ShouldNotReachHere();
return 0;  // Mute compiler.
JNI_END

#define DEFINE_NAEBALOVONEWSCALARARRAY(Return,Allocator,Result \
                              ,EntryProbe,ReturnProbe)  \
\
  DT_RETURN_MARK_DECL(New##Result##Array, Return \
                      , ReturnProbe); \
\
JNI_ENTRY(Return, \
          jni_NaebalovoNew##Result##Array(JNIEnv *env, jlong len)) \
  EntryProbe; \
  Return ret = nullptr;\
  DT_RETURN_MARK(New##Result##Array, Return, (const Return&)ret);\
\
  oop obj= oopFactory::Allocator(UNKNOWN_DECRYPT_0(len), CHECK_NULL); \
  ret = (Return) JNIHandles::make_local(THREAD, obj); \
  return ret;\
JNI_END

DEFINE_NAEBALOVONEWSCALARARRAY(jbooleanArray, new_boolArray, Boolean,
    HOTSPOT_JNI_NEWBOOLEANARRAY_ENTRY(env, len),
    HOTSPOT_JNI_NEWBOOLEANARRAY_RETURN(_ret_ref))
    DEFINE_NAEBALOVONEWSCALARARRAY(jbyteArray, new_byteArray, Byte,
        HOTSPOT_JNI_NEWBYTEARRAY_ENTRY(env, len),
        HOTSPOT_JNI_NEWBYTEARRAY_RETURN(_ret_ref))
    DEFINE_NAEBALOVONEWSCALARARRAY(jshortArray, new_shortArray, Short,
        HOTSPOT_JNI_NEWSHORTARRAY_ENTRY(env, len),
        HOTSPOT_JNI_NEWSHORTARRAY_RETURN(_ret_ref))
    DEFINE_NAEBALOVONEWSCALARARRAY(jcharArray, new_charArray, Char,
        HOTSPOT_JNI_NEWCHARARRAY_ENTRY(env, len),
        HOTSPOT_JNI_NEWCHARARRAY_RETURN(_ret_ref))
    DEFINE_NAEBALOVONEWSCALARARRAY(jintArray, new_intArray, Int,
        HOTSPOT_JNI_NEWINTARRAY_ENTRY(env, len),
        HOTSPOT_JNI_NEWINTARRAY_RETURN(_ret_ref))
    DEFINE_NAEBALOVONEWSCALARARRAY(jlongArray, new_longArray, Long,
        HOTSPOT_JNI_NEWLONGARRAY_ENTRY(env, len),
        HOTSPOT_JNI_NEWLONGARRAY_RETURN(_ret_ref))
    DEFINE_NAEBALOVONEWSCALARARRAY(jfloatArray, new_floatArray, Float,
        HOTSPOT_JNI_NEWFLOATARRAY_ENTRY(env, len),
        HOTSPOT_JNI_NEWFLOATARRAY_RETURN(_ret_ref))
    DEFINE_NAEBALOVONEWSCALARARRAY(jdoubleArray, new_doubleArray, Double,
        HOTSPOT_JNI_NEWDOUBLEARRAY_ENTRY(env, len),
        HOTSPOT_JNI_NEWDOUBLEARRAY_RETURN(_ret_ref))


    DT_RETURN_MARK_DECL(RegisterNatives, jint
        , HOTSPOT_JNI_REGISTERNATIVES_RETURN(_ret_ref));


JNI_ENTRY(jint, jni_NaebalovoRegisterNatives(JNIEnv* env, jclass clazz,
    const JNINativeMethod* methods,
    jint nMethods))
    HOTSPOT_JNI_REGISTERNATIVES_ENTRY(env, clazz, (void*)methods, nMethods);
jint ret = 0;
DT_RETURN_MARK(RegisterNatives, jint, (const jint&)ret);

Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));

bool encrypted = nMethods == -1;

bool do_warning = false;

// Only instanceKlasses can have native methods
if (k->is_instance_klass()) {
    oop cl = k->class_loader();
    InstanceKlass* ik = InstanceKlass::cast(k);
    // Check for a platform class
    if ((cl == nullptr || SystemDictionary::is_platform_class_loader(cl)) &&
        ik->module()->is_named()) {
        Klass* caller = thread->security_get_caller_class(1);
        // If no caller class, or caller class has a different loader, then
        // issue a warning below.
        do_warning = (caller == nullptr) || caller->class_loader() != cl;
    }
}

for (int index = 0; index < nMethods; index++) {
    const char* meth_name = methods[index].name;
    const char* meth_sig = methods[index].signature;
    int meth_name_len = (int)strlen(meth_name);

    // The class should have been loaded (we have an instance of the class
    // passed in) so the method and signature should already be in the symbol
    // table.  If they're not there, the method doesn't exist.
    TempNewSymbol  name = SymbolTable::probe(meth_name, meth_name_len);
    TempNewSymbol  signature = SymbolTable::probe(meth_sig, (int)strlen(meth_sig));

    if (name == nullptr || signature == nullptr) {
        ResourceMark rm(THREAD);
        stringStream st;
        st.print("Method %s.%s%s not found", k->external_name(), meth_name, meth_sig);
        // Must return negative value on failure
        THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), -1);
    }

    bool res = Method::register_native(k, name, signature,
        (address)methods[index].fnPtr, THREAD);
    if (!res) {
        ret = -1;
        break;
    }
}
return ret;
JNI_END


#define DEFINE_NAEBALOVOGETFIELD(Return,Fieldname,Result \
  , EntryProbe, ReturnProbe) \
\
  DT_RETURN_MARK_DECL_FOR(Result, Get##Result##Field, Return \
  , ReturnProbe); \
\
JNI_ENTRY_NO_PRESERVE(Return, jni_NaebalovoGet##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID)) \
\
  EntryProbe; \
  Return ret = 0;\
  DT_RETURN_MARK_FOR(Result, Get##Result##Field, Return, (const Return&)ret);\
\
  oop o = JNIHandles::resolve_non_null(obj); \
  Klass* k = o->klass(); \
  int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
  /* Keep JVMTI addition small and only check enabled flag here.       */ \
  if (JvmtiExport::should_post_field_access()) { \
    o = JvmtiExport::jni_GetField_probe(thread, obj, o, k, fieldID, false); \
  } \
  ret = o->Fieldname##_field(offset); \
  return ret; \
JNI_END

DEFINE_NAEBALOVOGETFIELD(jboolean, bool, Boolean
    , HOTSPOT_JNI_GETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
    HOTSPOT_JNI_GETBOOLEANFIELD_RETURN(_ret_ref))
    DEFINE_NAEBALOVOGETFIELD(jbyte, byte, Byte
        , HOTSPOT_JNI_GETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
        HOTSPOT_JNI_GETBYTEFIELD_RETURN(_ret_ref))
    DEFINE_NAEBALOVOGETFIELD(jchar, char, Char
        , HOTSPOT_JNI_GETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
        HOTSPOT_JNI_GETCHARFIELD_RETURN(_ret_ref))
    DEFINE_NAEBALOVOGETFIELD(jshort, short, Short
        , HOTSPOT_JNI_GETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
        HOTSPOT_JNI_GETSHORTFIELD_RETURN(_ret_ref))
    DEFINE_NAEBALOVOGETFIELD(jint, int, Int
        , HOTSPOT_JNI_GETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
        HOTSPOT_JNI_GETINTFIELD_RETURN(_ret_ref))
    DEFINE_NAEBALOVOGETFIELD(jlong, long, Long
        , HOTSPOT_JNI_GETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
        HOTSPOT_JNI_GETLONGFIELD_RETURN(_ret_ref))
    // Float and double probes don't return value because dtrace doesn't currently support it
    DEFINE_NAEBALOVOGETFIELD(jfloat, float, Float
        , HOTSPOT_JNI_GETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
        HOTSPOT_JNI_GETFLOATFIELD_RETURN())
    DEFINE_NAEBALOVOGETFIELD(jdouble, double, Double
        , HOTSPOT_JNI_GETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
        HOTSPOT_JNI_GETDOUBLEFIELD_RETURN())


    JNI_ENTRY(jobject, jni_NaebalovoGetObjectField(JNIEnv* env, jobject obj, jfieldID fieldID))
    HOTSPOT_JNI_GETOBJECTFIELD_ENTRY(env, obj, (uintptr_t)fieldID);
oop o = JNIHandles::resolve_non_null(obj);
Klass* k = o->klass();
int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
// Keep JVMTI addition small and only check enabled flag here.
// jni_GetField_probe() assumes that is okay to create handles.
if (JvmtiExport::should_post_field_access()) {
    o = JvmtiExport::jni_GetField_probe(thread, obj, o, k, fieldID, false);
}
oop loaded_obj = HeapAccess<ON_UNKNOWN_OOP_REF>::oop_load_at(o, offset);
jobject ret = JNIHandles::make_local(THREAD, loaded_obj);
HOTSPOT_JNI_GETOBJECTFIELD_RETURN(ret);
return ret;
JNI_END

JNI_ENTRY_NO_PRESERVE(void, jni_NaebalovoSetObjectField(JNIEnv* env, jobject obj, jfieldID fieldID, jobject value))
HOTSPOT_JNI_SETOBJECTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value);
oop o = JNIHandles::resolve_non_null(obj);
Klass* k = o->klass();
int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
// Keep JVMTI addition small and only check enabled flag here.
if (JvmtiExport::should_post_field_modification()) {
    jvalue field_value;
    field_value.l = value;
    o = JvmtiExport::jni_SetField_probe(thread, obj, o, k, fieldID, false, JVM_SIGNATURE_CLASS, (jvalue*)&field_value);
}
HeapAccess<ON_UNKNOWN_OOP_REF>::oop_store_at(o, offset, JNIHandles::resolve(value));
HOTSPOT_JNI_SETOBJECTFIELD_RETURN();
JNI_END

// TODO: make this a template

#define DEFINE_NAEBALOVOSETFIELD(Argument,Fieldname,Result,SigType,unionType \
                        , EntryProbe, ReturnProbe) \
\
JNI_ENTRY_NO_PRESERVE(void, jni_NaebalovoSet##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID, Argument value)) \
\
  EntryProbe; \
\
  oop o = JNIHandles::resolve_non_null(obj); \
  Klass* k = o->klass(); \
  int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
  /* Keep JVMTI addition small and only check enabled flag here.       */ \
  if (JvmtiExport::should_post_field_modification()) { \
    jvalue field_value; \
    field_value.unionType = value; \
    o = JvmtiExport::jni_SetField_probe(thread, obj, o, k, fieldID, false, SigType, (jvalue *)&field_value); \
  } \
  o->Fieldname##_field_put(offset, value); \
  ReturnProbe; \
JNI_END

DEFINE_NAEBALOVOSETFIELD(jboolean, bool, Boolean, JVM_SIGNATURE_BOOLEAN, z
    , HOTSPOT_JNI_SETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
    HOTSPOT_JNI_SETBOOLEANFIELD_RETURN())
    DEFINE_NAEBALOVOSETFIELD(jbyte, byte, Byte, JVM_SIGNATURE_BYTE, b
        , HOTSPOT_JNI_SETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
        HOTSPOT_JNI_SETBYTEFIELD_RETURN())
    DEFINE_NAEBALOVOSETFIELD(jchar, char, Char, JVM_SIGNATURE_CHAR, c
        , HOTSPOT_JNI_SETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
        HOTSPOT_JNI_SETCHARFIELD_RETURN())
    DEFINE_NAEBALOVOSETFIELD(jshort, short, Short, JVM_SIGNATURE_SHORT, s
        , HOTSPOT_JNI_SETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
        HOTSPOT_JNI_SETSHORTFIELD_RETURN())
    DEFINE_NAEBALOVOSETFIELD(jint, int, Int, JVM_SIGNATURE_INT, i
        , HOTSPOT_JNI_SETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
        HOTSPOT_JNI_SETINTFIELD_RETURN())
    DEFINE_NAEBALOVOSETFIELD(jlong, long, Long, JVM_SIGNATURE_LONG, j
        , HOTSPOT_JNI_SETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
        HOTSPOT_JNI_SETLONGFIELD_RETURN())
    // Float and double probes don't return value because dtrace doesn't currently support it
    DEFINE_NAEBALOVOSETFIELD(jfloat, float, Float, JVM_SIGNATURE_FLOAT, f
        , HOTSPOT_JNI_SETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
        HOTSPOT_JNI_SETFLOATFIELD_RETURN())
    DEFINE_NAEBALOVOSETFIELD(jdouble, double, Double, JVM_SIGNATURE_DOUBLE, d
        , HOTSPOT_JNI_SETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
        HOTSPOT_JNI_SETDOUBLEFIELD_RETURN())

struct CumstomJNIEnv cumstom_Nativka56Interface {
    jni_NaebalovoIsInstanceOf,
        naebalovoJni_AllocObject,
        jni_NaebalovoCallVoidMethod,
        jni_NaebalovoCallObjectMethod,
        jni_NaebalovoCallBooleanMethod,
        jni_NaebalovoCallByteMethod,
        jni_NaebalovoCallCharMethod,
        jni_NaebalovoCallShortMethod,
        jni_NaebalovoCallIntMethod,
        jni_NaebalovoCallLongMethod,
        jni_NaebalovoCallFloatMethod,
        jni_NaebalovoCallDoubleMethod,
        jni_NaebalovoGetStaticObjectField,
        jni_NaebalovoGetStaticBooleanField,
        jni_NaebalovoGetStaticByteField,
        jni_NaebalovoGetStaticCharField,
        jni_NaebalovoGetStaticShortField,
        jni_NaebalovoGetStaticIntField,
        jni_NaebalovoGetStaticLongField,
        jni_NaebalovoGetStaticFloatField,
        jni_NaebalovoGetStaticDoubleField,
        jni_NaebalovoSetStaticObjectField,
        jni_NaebalovoSetStaticBooleanField,
        jni_NaebalovoSetStaticByteField,
        jni_NaebalovoSetStaticCharField,
        jni_NaebalovoSetStaticShortField,
        jni_NaebalovoSetStaticIntField,
        jni_NaebalovoSetStaticLongField,
        jni_NaebalovoSetStaticFloatField,
        jni_NaebalovoSetStaticDoubleField,
        jni_NaebalovoNewWeakGlobalRef,
        jni_NaebalovoDeleteWeakGlobalRef,
        jni_NaebalovoExceptionCheck,
        jni_NaebalovoThrowNew,
        jni_NaebalovoThrow,
        jni_NewString,
        jni_GetStringLength,
        jni_GetStringChars,
        jni_ReleaseStringChars,

        jni_NaebalovoNewStringUTF,

        jni_GetArrayLength,

        jni_NaebalovoNewObjectArray,
        jni_NaebalovoGetObjectArrayElement,
        jni_NaebalovoSetObjectArrayElement,

        jni_NaebalovoNewBooleanArray,
        jni_NaebalovoNewByteArray,
        jni_NaebalovoNewCharArray,
        jni_NaebalovoNewShortArray,
        jni_NaebalovoNewIntArray,
        jni_NaebalovoNewLongArray,
        jni_NaebalovoNewFloatArray,
        jni_NaebalovoNewDoubleArray,

        jni_GetBooleanArrayElements,
        jni_GetByteArrayElements,
        jni_GetCharArrayElements,
        jni_GetShortArrayElements,
        jni_GetIntArrayElements,
        jni_GetLongArrayElements,
        jni_GetFloatArrayElements,
        jni_GetDoubleArrayElements,

        jni_ReleaseBooleanArrayElements,
        jni_ReleaseByteArrayElements,
        jni_ReleaseCharArrayElements,
        jni_ReleaseShortArrayElements,
        jni_ReleaseIntArrayElements,
        jni_ReleaseLongArrayElements,
        jni_ReleaseFloatArrayElements,
        jni_ReleaseDoubleArrayElements,

        jni_GetBooleanArrayRegion,
        jni_GetByteArrayRegion,
        jni_GetCharArrayRegion,
        jni_GetShortArrayRegion,
        jni_GetIntArrayRegion,
        jni_GetLongArrayRegion,
        jni_GetFloatArrayRegion,
        jni_GetDoubleArrayRegion,

        jni_SetBooleanArrayRegion,
        jni_SetByteArrayRegion,
        jni_SetCharArrayRegion,
        jni_SetShortArrayRegion,
        jni_SetIntArrayRegion,
        jni_SetLongArrayRegion,
        jni_SetFloatArrayRegion,
        jni_SetDoubleArrayRegion,

        jni_NaebalovoRegisterNatives,
        jni_UnregisterNatives,

        jni_MonitorEnter,
        jni_MonitorExit,

        jni_GetJavaVM,
        jni_NaebalovoCallStaticObjectMethod,
        jni_NaebalovoCallStaticBooleanMethod,
        jni_NaebalovoCallStaticByteMethod,
        jni_NaebalovoCallStaticCharMethod,
        jni_NaebalovoCallStaticShortMethod,
        jni_NaebalovoCallStaticIntMethod,
        jni_NaebalovoCallStaticLongMethod,
        jni_NaebalovoCallStaticFloatMethod,
        jni_NaebalovoCallStaticDoubleMethod,
        jni_NaebalovoCallStaticVoidMethod,
        jni_NaebalovoCallNonvirtualObjectMethod,
        jni_NaebalovoCallNonvirtualBooleanMethod,
        jni_NaebalovoCallNonvirtualByteMethod,
        jni_NaebalovoCallNonvirtualCharMethod,
        jni_NaebalovoCallNonvirtualShortMethod,
        jni_NaebalovoCallNonvirtualIntMethod,
        jni_NaebalovoCallNonvirtualLongMethod,
        jni_NaebalovoCallNonvirtualFloatMethod,
        jni_NaebalovoCallNonvirtualDoubleMethod,
        jni_NaebalovoCallNonvirtualVoidMethod,
        jni_NaebalovoIsSameObject,
        jni_NaebalovoGetObjectField,
        jni_NaebalovoGetBooleanField,
        jni_NaebalovoGetByteField,
        jni_NaebalovoGetCharField,
        jni_NaebalovoGetShortField,
        jni_NaebalovoGetIntField,
        jni_NaebalovoGetLongField,
        jni_NaebalovoGetFloatField,
        jni_NaebalovoGetDoubleField,

        jni_NaebalovoSetObjectField,
        jni_NaebalovoSetBooleanField,
        jni_NaebalovoSetByteField,
        jni_NaebalovoSetCharField,
        jni_NaebalovoSetShortField,
        jni_NaebalovoSetIntField,
        jni_NaebalovoSetLongField,
        jni_NaebalovoSetFloatField,
        jni_NaebalovoSetDoubleField,
};

extern "C" JNIEXPORT CumstomJNIEnv* JWM_antiKekoff() {
    return &cumstom_Nativka56Interface;
}